<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试题 | 张佩服的Blog</title><meta name="keywords" content="面试题"><meta name="author" content="Dengzm2022"><meta name="copyright" content="Dengzm2022"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、 JAVA基础部分 1.1、基础内容【必须】 1. JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。 **具体来说 JDK 其实包含了 JRE，同时还包含了编译 Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://dengzm2022.github.io/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="张佩服的Blog">
<meta property="og:description" content="一、 JAVA基础部分 1.1、基础内容【必须】 1. JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。 **具体来说 JDK 其实包含了 JRE，同时还包含了编译 Ja">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/07/02/8dSbYDP6t1NiexJ.webp">
<meta property="article:published_time" content="2022-09-18T12:03:49.000Z">
<meta property="article:modified_time" content="2022-09-18T12:07:01.849Z">
<meta property="article:author" content="Dengzm2022">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/07/02/8dSbYDP6t1NiexJ.webp"><link rel="shortcut icon" href="https://s2.loli.net/2022/07/02/wevdzYikc6EoaXn.jpg"><link rel="canonical" href="http://dengzm2022.github.io/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-18 20:07:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/07/02/wevdzYikc6EoaXn.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/07/02/8dSbYDP6t1NiexJ.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">张佩服的Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2022-09-18T12:07:01.849Z" title="更新于 2022-09-18 20:07:01">2022-09-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaEE/">JavaEE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>103分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><strong>一、</strong> <strong>JAVA基础部分</strong></h1>
<h2 id="1-1、基础内容【必须】"><strong>1.1、基础内容【必须】</strong></h2>
<h4 id="1-JDK-和-JRE-有什么区别？"><strong>1.</strong> <strong>JDK 和 JRE 有什么区别？</strong></h4>
<p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</p>
<p>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</p>
<p>**具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。**简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>
<h4 id="2-抽象类与接口区别"><strong>2.</strong> <strong>抽象类与接口区别</strong></h4>
<p>Ø 抽象类可以有构造方法，接口中不能有构造方法</p>
<p>Ø 抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>Ø 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的</p>
<p>Ø 抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型</p>
<p>Ø 抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>Ø 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型</p>
<p>Ø 一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p>Ø 接口关注的是功能，抽象类关注的抽象现实中事物</p>
<p>关键点：抽象类可以有构造方法，接口中不能有构造方法、抽象类中可以有普通成员变量，接口中没有普通成员变量、一个类可以实现多个接口，但只能继承一个抽象类。</p>
<h4 id="3-和-equals-的区别是什么？"><strong>3.</strong> <strong>== 和 equals 的区别是什么？</strong></h4>
<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p>
<p>equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="4-Stream常用方法："><strong>4.</strong> <strong>Stream常用方法：</strong></h4>
<p>Ø map: 用作类型转换 如把集合里面的字符串转为大写,或者一个对象的集合取几个字段转为新的对象集合</p>
<p>Ø filter: 过滤 符合条件的集合元素保存下来,不符合条件的去掉</p>
<p>Ø flatMap:合并集合,比如List<Album> Album里面有一LIst<Track> 对象,这个时候就能不通过循环的方式把 List<Album> 里的每一个元素的 trasks 对象组装成一个新的集合</p>
<p>Ø reduce: reduce可以做累加运算, .reduce(0, (a,b)-&gt; a+b);</p>
<p>Ø count: count和size一样返回的是元素的个数</p>
<p>Ø max,min: 求最大值和最小值,这两个方法需要传入一个comparator比较器,Comparator比较器有一个comparing() 方法</p>
<p>Ø anyMatch表示，判断的条件里，任意一个元素成功，返回true</p>
<p>Ø allMatch表示，判断条件里的元素，所有的都是，返回true</p>
<p>map、filter</p>
<h4 id="5-final-在-Java-中有什么作用？"><strong>5.</strong> <strong>final 在 Java 中有什么作用？</strong></h4>
<p>final 修饰的类叫最终类，该类不能被继承。<br>
final 修饰的方法不能被重写。<br>
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h4 id="6-String-类的常用方法都有那些？"><strong>6.</strong> <strong>String 类的常用方法都有那些？</strong></h4>
<p><strong>indexOf()：返回指定字符的索引。</strong></p>
<p>charAt()：返回指定索引处的字符。</p>
<p><strong>replace()：字符串替换。</strong></p>
<p>trim()：去除字符串两端空白。</p>
<p><strong>split()：分割字符串，返回一个分割后的字符串数组。</strong></p>
<p>getBytes()：返回字符串的 byte 类型数组。</p>
<p>length()：返回字符串长度。</p>
<p>toLowerCase()：将字符串转成小写字母。</p>
<p>toUpperCase()：将字符串转成大写字符。</p>
<p><strong>substring()：截取字符串。</strong></p>
<p>equals()：字符串比较。</p>
<h4 id="7-字符串中replace和replaceAll的区别？"><strong>7.</strong> <strong>字符串中replace和replaceAll的区别？</strong></h4>
<p>Ø replace的第一个参数是char和CharSequence,即可以支持字符和字符串的替换。</p>
<p>Ø replaceAll的第一个参数是regex，即基于规则表达式的替换。</p>
<h4 id="8-String-StringBuilder-StringBuffer三者的区别"><strong>8.</strong> <strong>String,</strong>    <strong>StringBuilder,StringBuffer三者的区别</strong></h4>
<p>l String和StringBuilder的本质区别</p>
<p>String是一个不可改变的字符序列.</p>
<p>StringBuilder是一个可以改变的字符序列.</p>
<p>l 常见的字符拼接,该选择谁</p>
<p>推荐使用StringBuilder,因为拼接的效率高</p>
<p>l StringBuilder和StringBuffer的区别</p>
<p>一、StringBuilder和StringBuffer的功能是完全一致的.</p>
<p>二、不同点</p>
<p>StringBuffer是jdk1.0出现的,线程安全(同步):效率低.</p>
<p>StringBuilder是jdk1.5出现的,线程不安全(不同步):效率高.</p>
<h4 id="9-JAVA反射机制提供了什么功能"><strong>9.</strong> <strong>JAVA反射机制提供了什么功能</strong></h4>
<p><strong>Java反射机制提供如下功能</strong>：</p>
<p>Ø 在运行时判断任意一个对象所属的类</p>
<p>Ø 在运行时构造任意一个类的对象</p>
<p>Ø 在运行时判段任意一个类所具有的成员变量和方法</p>
<p>Ø 在运行时调用任一个对象的方法</p>
<p>Ø 在运行时创建新类对象</p>
<p>Ø 在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。</p>
<p>Class  à    Contructor  +  Field  +  Method</p>
<h4 id="10-常见的异常类有哪些？"><strong>10.</strong> <strong>常见的异常类有哪些？</strong></h4>
<p>Ø NullPointerException 空指针异常【少做空判断】</p>
<p>Ø ClassNotFoundException 指定类不存在【包冲突】</p>
<p>Ø NumberFormatException 字符串转换为数字异常【1a23：检查：正则判断，hutool工具类】</p>
<p>Ø IndexOutOfBoundsException 数组下标越界异常</p>
<p>Ø ClassCastException 数据类型转换异常</p>
<p>Ø FileNotFoundException 文件未找到异常</p>
<p>Ø NoSuchMethodException 方法不存在异常</p>
<p>Ø IOException IO 异常</p>
<p>Ø SocketException Socket 异常</p>
<h4 id="11-Java中异常处理机制"><strong>11.</strong> <strong>Java中异常处理机制</strong></h4>
<p>l 什么是异常</p>
<p>异常指的就是程序的不正常,简单理解就是程序所发生的错误.</p>
<p>l 异常的体系结构&amp;分类</p>
<p>一、分类</p>
<ol>
<li>
<p>编译时异常:指的就是编译期间,编译器检测到某段代码可能会发生某些问题,需要程序员提前给代码做出错误的解决方案,否则编译是不通过的.(例如FileReader)</p>
</li>
<li>
<p>运行时异常:指的是编译通过了,但运行时出现的错误.</p>
</li>
</ol>
<p>**二、**<strong>体系结构</strong></p>
<p>Throwable</p>
<p>Error：严重性错误</p>
<p>Exception：</p>
<p>RuntimeException:  运行时异常</p>
<p>!RuntimeException: 编译时异常</p>
<p>l 异常产生的原理</p>
<p>java对异常默认的处理方式,是将问题抛出给上一级</p>
<p>抛出之前,java会根据错误产生的异常类,创建出该类的对象,底层并通过throw关键字将异常抛出给上一级,不断向上抛出,直到抛给了JVM虚拟机,虚拟机拿到问题之后,就会将错误的原因和所在的位置,打印在控制台.</p>
<p>l 异常的处理方式</p>
<p>一、问题可以自己处理掉的</p>
<p>try…catch处理方式:自己将问题处理掉,不会影响到后续代码的继续执行.</p>
<p>二、问题自己处理不掉的</p>
<p>throws抛出处理方式：如果发现问题自己无法完美结局,就可以通过throw关键字,将异常对象抛出给调用者,但如果使用throw抛出异常对象,则方法上面必须进行throws的声明,告知调用者此方法存在异常.</p>
<p>细节:如果抛出的对象是RuntimeException,则方法上面无需throws声明.</p>
<p>总结：逐层上抛，在springmvc中使用统一异常处理来处理。</p>
<p>@ControllerAdvice + @ExceptinHandler(xxx.class)</p>
<h4 id="12-Java中finally和return执行顺序"><strong>12.</strong> <strong>Java中finally和return执行顺序</strong></h4>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014082714/article/details/106050735">(48条消息) Java中finally和return执行顺序_liuhmmjj的博客-CSDN博客_finally return执行顺序</a></p>
<p>Ø finally语句在return语句执行之后 return返回之前执行的</p>
<p>Ø finally块中的return语句会覆盖try块中的return返回</p>
<p>Ø 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变</p>
<p>Ø try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况</p>
<p>Ø 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样</p>
<h4 id="13-常见的基本排序"><strong>13.</strong> <strong>常见的基本排序</strong></h4>
<p>l 冒泡排序</p>
<p>public void bubbleSort(int[] arr) { //从小到大</p>
<p>​	int temp = 0;</p>
<p>​	for(int i = 0; i &lt; arr.length -1; i++){ //控制趟数，到倒数第二个为止</p>
<p>​		for(int j = arr.length-1; j&gt;i; j–){ //从最后一个值开始冒泡，将后面的小值与前面的大值进行交换，并且保证循环到前面已经排序完的索引为止</p>
<p>​			if(arr[j-1] &gt; arr[j]){</p>
<p>​				temp = arr[j];</p>
<p>​				arr[j] = arr[j-1];</p>
<p>​				arr[j-1] = temp;</p>
<p>​			}</p>
<p>​		}</p>
<p>​	}</p>
<p>}</p>
<p>l 选择排序：</p>
<p>public void selectionSort(int[] arr){</p>
<p>​	int temp = 0;</p>
<p>​	int k = 0; //存储最小值的索引</p>
<p>​	for(int i = 0; i&lt;arr.lengrh - 1; i++){ //控制趟数，到倒数第二个为止</p>
<p>​		k = i;</p>
<p>​		for(int j = i; j&lt;arr.length;j++){  //将第一个数默认为最小值，将其索引赋值给k，从k索引开始，将后面每个数与k索引对应的值比较，如果值小了，就将其索引赋值给k</p>
<p>​			if(arr[j] &lt; arr[k]){</p>
<p>​				k = j;</p>
<p>​			}</p>
<p>​		}</p>
<p>​		//遍历完后，k就指向了最小的值，将其与i对应的值交换(也可 以先做个判断，判断k的索引是否有变化，无变化可以不交换)</p>
<p>​		temp = arr[k];</p>
<p>​		arr[k] = arr[i];</p>
<p>​		arr[i] = temp;</p>
<p>​	}</p>
<p>​</p>
<p>}</p>
<p>总结：记住一两个常见的排序【冒泡】</p>
<h2 id="1-2-、JVM虚拟机-类加载"><strong>1.2</strong>**、JVM虚拟机&amp;类加载**</h2>
<h4 id="1-Java-内存区域【必须，记住结果】"><strong>1.</strong> <strong>Java 内存区域【必须，记住结果】</strong></h4>
<p>Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、元数据区。</p>
<p>JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。</p>
<p>为什么要使用元空间取代永久代的实现？</p>
<p>\1. 字符串存在永久代中，容易出现性能问题和内存溢出。</p>
<p>\2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p>
<p>\3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
<p>\4. 将 HotSpot 与 JRockit 合二为一。</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps1.jpg)</p>
<h4 id="2-JAVA中垃圾回收机制【记住常见的垃圾回收算法】"><strong>2.</strong> <strong>JAVA中垃圾回收机制【记住常见的垃圾回收算法】</strong></h4>
<p>l 什么样的对象会被当做垃圾回收</p>
<p>当一个对象的引用(地址)没有变量去记录的时候,该对象就会成为垃圾对象,并在垃圾回收器空闲的时候对其进行清扫.</p>
<p>l 如何检验对象是否被回收</p>
<p>可以重写Object类中的finalize方法</p>
<p>这个方法在垃圾回收器执行的时候,被回收器自动调用执行的.</p>
<p>l 怎样通知垃圾回收器回收对象</p>
<p>可以调用system类的静态方法gc().通知垃圾回收器去清理垃圾.</p>
<p>1、标记清除算法</p>
<p>特点： 简单、收集速度快，但会有空间碎片，空间碎片会导致后面的GC频率增加。</p>
<p>适合场景：只有小部分对象需要进行回收的，适用于老年代的垃圾回收，因为老年代一般存活对象会比回收对象要多。</p>
<p>2、标记复制算法</p>
<p>特点：收集速度快，可以避免空间碎片，但是有空间浪费，存活对象较多的情况下复制对象的过程等会非常耗时，而且需要担保机制。</p>
<p>适合场景： 只有少量对象存活的场景，这也正是新生代对象的特点，所以一般新生代的垃圾回收器基本都会选择标记复制法。</p>
<p>3、标记整理算法</p>
<p>特点： 相对于标记复制法不会浪费内存空间，相对标记清除法则可以避免空间碎片，但是速度比其他两个算法慢。</p>
<p>适合场景： 内存吃紧，又要避免空间碎片的场景，老年代想要避免空间碎片问题的话通常会使用标记整理法。</p>
<h4 id="3-类加载过程【必须】"><strong>3.</strong> <strong>类加载过程【必须】</strong></h4>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps2.jpg)加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化：</p>
<p>Ø 加载:</p>
<p>1.获取类的二进制字节流</p>
<p>2.将字节流代表的静态存储结构转化为方法区运行时数据结构，在堆中生成class字节码对象</p>
<p>Ø 验证:连接过程的第一步,确保class文件的字节流中的信息符合当前虚拟机的要求,不会危害虚拟机的安全</p>
<p>Ø 准备:为类的静态变量分配内存并将其初始化为默认值</p>
<p>Ø 解析:虚拟机将常量池内符号引用替换成直接引用的过程</p>
<p>Ø 初始化:执行类构造器的init的过程</p>
<h4 id="4-类的实例化方法调用顺序"><strong>4.</strong> <strong>类的实例化<strong><strong>方法调用</strong></strong>顺序</strong></h4>
<p>此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。<br>
父类静态代变量、<br>
父类静态代码块、<br>
子类静态变量、<br>
子类静态代码块、<br>
父类非静态变量（父类实例成员变量）、<br>
父类构造函数、<br>
子类非静态变量（子类实例成员变量）、<br>
子类构造函数。</p>
<h4 id="5-对象创建过程"><strong>5.</strong> <strong>对象创建过程</strong></h4>
<p>Ø JVM会先去方法区下找有没有所创建对象的类存在，有就可以创建对象了，没有则把该类加载到方法区</p>
<p>Ø 在创建类的对象时，首先会先去堆内存中分配空间</p>
<p>Ø 当空间分配完后，加载对象中所有的非静态成员变量到该空间下</p>
<p>Ø 所有的非静态成员变量加载完成之后，对所有的非静态成员进行默认初始化</p>
<p>Ø 所有的非静态成员默认初始化完成之后，调用相应的构造方法到栈中</p>
<p>Ø 在栈中执行构造函数时，先执行隐式，再执行构造方法中书写的代码</p>
<p>Ø 执行顺序：静态代码库，构造代码块，构造方法</p>
<p>Ø 当整个构造方法全部执行完，此对象创建完成，并把堆内存中分配的空间地址赋给对象名（此时对象名就指向了该空间）</p>
<h4 id="6-Java-内存溢出"><strong>6.</strong> <strong>Java****内存溢出</strong></h4>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zuishengmengsi1990/article/details/120093015">(48条消息) 9.内存溢出_zuishengmengsi1990的博客-CSDN博客</a></p>
<p>Ø Java堆溢出：</p>
<p>​	Java堆用于存储对象实例，只要不断地创建对象，当对象数量到达最大堆的容量限制后就会产生内存溢出异常。最常见的内存溢出就是存在大的容器，而没法回收，比如：Map，List等。</p>
<p>java.lang.OutOfMemoryError: Java heap space</p>
<p>Ø 虚拟机栈和本地方法栈溢出</p>
<p>​	如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，请见情况：递归调用，无法退出。</p>
<p>​	如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常，线程创建过多导致，每个线程需要申请栈空间。</p>
<p>java.lang.OutOfMemoryError: unable to create new native thread</p>
<p>Ø 元数据区域的内存溢出：</p>
<p>java.lang.OutOfMemoryError: Metaspace</p>
<p>元数据区域或方法区是用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。我们可以通过在运行时产生大量的类去填满方法区，直到溢出，如：代理的使用(CGlib)、大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java的Servlet类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等</p>
<p>Ø 运行时常量池的内存溢出：</p>
<p>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p>
<p>java.lang.OutOfMemoryError : PermGen space</p>
<p>Ø 直接内存溢出</p>
<p>使用这个unsafe类的native方法allocateMemory去直接申请内存导致的内存溢出。</p>
<p>总结：记住前两个！！</p>
<h4 id="7-java内存泄漏"><strong>7.</strong> <strong>java内存泄漏</strong></h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368830445">Java 内存泄漏原因、解决办法及泄漏排查 - 知乎 (zhihu.com)</a></p>
<h2 id="1-4-、多线程【必须】"><strong>1.4</strong>**、多线程【必须】**</h2>
<h4 id="1-线程和进程的区别？"><strong>1.</strong> <strong>线程和进程的区别？</strong></h4>
<p>Ø 进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>Ø 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
<p><strong>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</strong></p>
<h4 id="2-创建线程的方式"><strong>2.</strong> <strong>创建线程的方式</strong></h4>
<p>l 继承Thread类</p>
<p>优点:代码简单</p>
<p>缺点:该类无法继承别的类</p>
<p>l 实现Runnable接口</p>
<p>优点:继承其他类.统一实现该接口的实例可以共享资源.</p>
<p>缺点:代码复杂.</p>
<p>l 实现Callable接口</p>
<p>Callable中的call()方法有返回值,其他和Runnable的run()方法一样.</p>
<p>l 线程池方式</p>
<p>优点:实现自动化装配,易于管理,循环利用资源.</p>
<p>总结：</p>
<p>new Thread</p>
<p>new Thread的子类</p>
<p>而Runnable 和 Callable 是线程需要执行的任务</p>
<p>线程启动： start()【是的】 vs  run()【不是】</p>
<p>Runnable和 Callable 的区别，Callabe可以有返回值。</p>
<h4 id="3-Java中wait方法和sleep方法的不同之处"><strong>3.</strong> <strong>Java中wait方法和sleep方法的不同之处</strong></h4>
<p><strong>共同点：</strong></p>
<p>​	wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</p>
<p><strong>不同点：</strong></p>
<p>Ø 方法归属不同</p>
<p>sleep(long) 是 Thread 的静态方法，而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</p>
<p>Ø 醒来时机不同</p>
<p>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</p>
<p>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</p>
<p>它们都可以被打断唤醒</p>
<p>Ø 锁特性不同（重点）</p>
<p>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制；</p>
<p>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）；</p>
<p>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）。</p>
<h4 id="4-线程的状态"><strong>4.</strong> <strong>线程的状态</strong></h4>
<p>Ø 就绪(Runnable):线程准备运行，不一定立马就能开始执行。</p>
<p>Ø 运行中(Running)：进程正在执行线程的代码。</p>
<p>Ø 等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。</p>
<p>Ø 睡眠中(Sleeping)：线程被强制睡眠。</p>
<p>Ø 阻塞：</p>
<p>I/O阻塞(Blocked on I/O)：等待I/O操作完成。</p>
<p>同步阻塞(Blocked on Synchronization)：等待获取锁。</p>
<p>Ø 死亡(Dead)：线程完成了执行。</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps3.jpg)</p>
<p><strong>总结：</strong></p>
<p>start  -&gt;  运行    -&gt;   结束</p>
<p>运行 -&gt;  wait() / join() 【等待】  -&gt;  notify()/notifyAll()   -&gt; 运行</p>
<p>运行 -&gt;  sleep(10)/wait(10)/join(10) 【超时等待】  -&gt;  notify()/notifyAll()/超时  -&gt; 运行</p>
<p>运行 -&gt;  synchroinzied 争锁  【阻塞】  -&gt;  获取锁   -&gt; 运行</p>
<h4 id="5-线程池的种类-【必须】"><strong>5.</strong> <strong>线程池的种类</strong>**【必须】**</h4>
<p>Ø newCachedThreadPool创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>Ø newFixedThreadPool 创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>Ø newScheduledThreadPool 创建一个<strong>定长线程池，支持定时及周期性任务执行</strong>。</p>
<p>Ø newSingleThreadExecutor 创建一个<strong>单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p>
<p>因为在项目中，线程的创建和销毁非常消耗资源，所以使用在多线程场景的时候会使用线程池，根据自己业务逻辑的需求，使用不同的线程池。</p>
<p><strong>一个都不建议使用！！！！</strong></p>
<p>总结：</p>
<p>java.util.concurrent：JUC，java并发包，用于多线程开发！！！</p>
<p>Executors：用于创建线程池对象的工具类：</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps4.jpg)</p>
<p>ThreadPoolExecutor  线程池类，要记住！！</p>
<h4 id="6-线程池的核心参数？【必须】"><strong>6.</strong> <strong>线程池的核心参数？【必须】</strong></h4>
<p>自己找！！看tlias上的视频</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps5.jpg)</p>
<h4 id="7-线程池都有哪些状态？"><strong>7.</strong> <strong>线程池都有哪些状态？</strong></h4>
<p>Ø RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p>
<p>Ø SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p>
<p>Ø STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p>
<p>Ø TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</p>
<p>Ø TERMINATED：terminated()方法结束后，线程池的状态就会变成这个</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps6.jpg)</p>
<h4 id="8-线程同步"><strong>8.</strong> <strong>线程同步</strong></h4>
<p>Ø 线程同步：实现共享数据的一致性，让多个线程有序的访问共享资源，而不是同时操作共享资源</p>
<p>Ø 方法同步：用关键字 synchonized 可将方法声明为同步</p>
<p>Ø 同步代码块：synchornized 获取的是参数中的对象锁，synchornized(obj){}</p>
<p>Ø 同步类的属性：在类中声明多个object对象，对每个代码块分别操作类的不同属性加锁的时候就分别使用object对象来作为锁，这样能保证多个线程同时运行，分别操作不同的对象</p>
<p>Ø synchronized 静态方法与非静态方法：非静态同步方法的锁对象是this，静态的同步方法的锁对象是当前类的字节码对象</p>
<p>Ø 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bird_tp/article/details/108537524">(48条消息) java如何实现线程同步_bird_tp的博客-CSDN博客_java线程同步</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/bird_tp/article/details/108537524">(48条消息) java如何实现线程同步_bird_tp的博客-CSDN博客_java线程同步</a></p>
<h4 id="9-volatile与synchronized的区别，底层实现"><strong>9.</strong> <strong>volatile与synchronized的区别，底层实现</strong></h4>
<p>l 首先两者都是用来确保数据的一致性的，volatile它能够使变量在值发生改变时尽快让其他线程知道，为什么要这么做呢？编译器为了加快程序运行速度，对一些变量的写操作会现在寄存器或者是cpu缓存上进行，最后才写入内存，这个过程，变量的新值对其他线程是不可见的，而volatile的作用就是使它修饰的变量的读写操作都必须在内存中进行</p>
<p>区别：</p>
<p>l Volatile本质是告诉jvm当前变量在寄存器中的值是不安全的需要从内存中读取，sychronized则是锁定当前变量，只有当前线程可以访问到该变量其他线程被阻塞</p>
<p>l Volatile只能作用于变量，synchronized则是可以使用在变量和方法上</p>
<p>l Volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性</p>
<p>l volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞</p>
<p>l volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化</p>
<p>注意事项：</p>
<p>l 在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原来操作，当变量的值由自身的上一个决定时，如n=n+1、n++ 等，volatile关键字将失效，只有当变量的值和自身上一个值无关时对该变量的操作才是原子级别的，如n = m + 1，这个就是原级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile</p>
<h4 id="10-什么是死锁？【必须】"><strong>10.</strong> <strong>什么是死锁？【必须】</strong></h4>
<p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h4 id="11-怎么防止死锁？【必须】"><strong>11.</strong> <strong>怎么防止死锁？【必须】</strong></h4>
<p>l 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</p>
<p>l 尽量使用 Java.util.concurrent 并发类代替自己手写锁。</p>
<p>l 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</p>
<p>l 尽量减少同步的代码块。</p>
<h2 id="1-5-、IO模型【3年左右】"><strong>1.5</strong>**、I<strong><strong>O</strong></strong>模型【3年左右】**</h2>
<h4 id="IO对比总结"><strong>IO对比总结</strong></h4>
<p>Ø IO 的方式通常分为几种：同步阻塞的 BIO、同步非阻塞的 NIO、异步非阻塞的 AIO。</p>
<p>Ø BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。</p>
<p>Ø NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。</p>
<p>Ø AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</p>
<p>举个例子：</p>
<p>Ø 同步阻塞：你到饭馆点餐，然后在那等着，啥都干不了，饭馆没做好，你就必须等着！</p>
<p>Ø 同步非阻塞：你在饭馆点完餐，就去玩儿了。不过玩一会儿，就回饭馆问一声：好了没 啊！</p>
<p>Ø 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心玩儿就可以了， 类似于现在的外卖。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/670033e5b916">8. Java-IO模型（BIO、NIO、AIO） - 简书 (jianshu.com)</a></p>
<h2 id="1-6-、Java容器【必须】"><strong>1.6</strong>**、Java容器【必须】**</h2>
<h4 id="1-Java-容器都有哪些？"><strong>1.</strong> <strong>Java 容器都有哪些？</strong></h4>
<p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>Collection：List【ArrayList】  Set【HashSet】</p>
<p>List、ArrayList、LinkedList、Vector、Stack、Set、HashSet、LinkedHashSet、TreeSet</p>
<p>Map：</p>
<p>HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable</p>
<h4 id="2-数组与链表的区别？"><strong>2.</strong> <strong>数组与链表的区别？</strong></h4>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps7.png)</p>
<p>1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；</p>
<p>2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；</p>
<p>3、存储空间上，链表由于带有指针域，存储密度不如数组大；</p>
<p>4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；</p>
<p>5、按值查找时，若数组无序，数组和链表时间复杂度均为O(n)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；</p>
<p>6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；</p>
<p>7、空间分配方面：<br>
　　数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；<br>
　　链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；</p>
<p><strong>总结：</strong></p>
<p>​	<strong>数组随机访问性强，查找速度快，但是插入和删除效率低</strong>**；而且数组大小固定，不能动态扩展，数组要求必须有连续的内存空间，内存空间要求高。**</p>
<p>​	<strong>链表插入删除速度快，大小不固定，拓展很灵活。但是不能随机查找</strong>**，必须从第一个开始遍历，查找效率低**</p>
<h4 id="3-Map集合几种遍历方式"><strong>3.</strong> <strong>Map集合几种遍历方式?</strong></h4>
<p>第一种: 通过Map.keySet获取key的Set集合，之后在通过key进行遍历</p>
<p>第二种: 通过Map.values获取所有value，之后再进行遍历</p>
<p>第三种: 通过Map.entrySet获取Set集合，之后通过iterator进行遍历</p>
<p>第四种: 直接通过foreach对Map.entrySet获取的Set集合进遍历</p>
<h4 id="4-List集合的特性"><strong>4.</strong> <strong>List集合的特性</strong></h4>
<p>有序可重复的集合</p>
<h4 id="5-如何实现数组和-List-之间的转换？"><strong>5.</strong> <strong>如何实现数组和 List 之间的转换？</strong></h4>
<p>数组转 List：使用 Arrays.asList(array) 进行转换。</p>
<p>List 转数组：使用 List 自带的 toArray() 方法。</p>
<h4 id="6-ArrayList-和-LinkedList-有什么区别"><strong>6.</strong> <strong>ArrayList 和 LinkedList 有什么区别</strong></h4>
<p><strong>Ø</strong> <strong>ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。</strong></p>
<p>Ø 对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。</p>
<p>Ø 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
<p>总结：抓住第一个问题！！</p>
<h4 id="7-list、set和map的区别"><strong>7.</strong> <strong>list、set和map的区别</strong></h4>
<p>list和set是实现了collection接口的。</p>
<p>List：1.可以允许重复的对象。</p>
<p>2.可以插入多个null元素。</p>
<p>​    3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。</p>
<p>4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p>
<p>Set：</p>
<p>1.不允许重复对象</p>
<p>\2. 无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator  或者 Comparable 维护了一个排序顺序。</p>
<p>​    \3. 只允许一个 null 元素Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</p>
<p>Map不是collection的子接口或者实现类。Map是一个接口。</p>
<p>1.Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。</p>
<p>2.TreeMap 也通过 Comparator或者Comparable 维护了一个排序顺序。</p>
<p>3.Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。</p>
<p>4.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</p>
<p><strong>总结：</strong></p>
<p><strong>list和set都是实现了<strong><strong>collection</strong></strong>接口的集合，其中list是有序可重复的，而set是无须不可重复的；</strong></p>
<p><strong>而<strong><strong>M</strong></strong>ap是一个独立的接口，不是<strong><strong>collection</strong></strong>的子接口，map中存储的是key</strong>**-**<strong>value键值对的数据。</strong></p>
<h4 id="8-HashMap的特性"><strong>8.</strong> <strong>HashMap的特性</strong></h4>
<p>l Map集合的特点</p>
<p>一、Map是一个双列集合,将键映射到值的对象.</p>
<p>二、Map集合的数据结构,只针对键有效,跟值没关系.</p>
<p>三、一个映射不能包含重复的键,每个键最多只能映射一个值.</p>
<p>l HashMap的数据结构</p>
<p>一、哈希表结构:数组+链表</p>
<p>二、通过哈希表结构配合对象的hashCode和equals方法就可以确保键的唯一性.</p>
<p>l HashMap和Hashtable的区别</p>
<p>一、HashMap是jdk1.2版本出现的,允许存储null键和null值</p>
<p>不同步(线程不安全):效率高</p>
<p>二、Hashtable是jdk1.0版本出现的,不允许存储null键和null值</p>
<p>同步(线程安全):效率低</p>
<h4 id="9-A-rrayList的扩容规则？"><strong>9.</strong> <strong>A****rrayList的扩容规则？</strong></h4>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps8.jpg)</p>
<h4 id="10-说一下-HashMap-的实现原理？【重中之重】"><strong>10.</strong> <strong>说一下 HashMap 的实现原理？【重中之重】</strong></h4>
<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h4 id="11-说一下-HashSet-的实现原理？"><strong>11.</strong> <strong>说一下 HashSet 的实现原理？</strong></h4>
<p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h4 id="12-CurrentHashMap了解吗"><strong>12.</strong> <strong>CurrentHashMap了解吗?</strong></h4>
<p>HashMap是线程不安全的 , 但是效率高 , HashTable是线程安全的 , 但是效率低.有没有一种对象是即是线程安全的 , 同时执行效率可以达到HashMap呢?</p>
<p>CurrentHashMap可以做到。底层实现通过分段加锁进行实现 , hashmap底层是数组加上链表实现的 , 那么一个线程来操作数据,只是操作数组中一个索引的数据. 如果此时对整个数组加锁,其他线程操作不了这个数组,所以效率低.其实线程也就操作数组的一个索引,对这个索引进行加锁 , 而锁对象就是这个索引所对应的值,其他线程来修改其他索引数据时,拿到的是其他索引的锁对象,从而提高了效率.</p>
<h2 id="1-7-、Java设计模式"><strong>1.7</strong>**、J<strong><strong>ava</strong></strong>设计模式**</h2>
<h4 id="1-常见设计模式"><strong>1.</strong> <strong>常见设计模式</strong></h4>
<p><strong>Ø</strong> <strong>工厂模式</strong>：一个抽象接口的实现，多个抽象接口的实现类，spring的beanFactory就是工厂模式   <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39504520/article/details/106364731">(48条消息) 工厂设计模式_coyhzx的博客-CSDN博客_工厂设计模式</a></p>
<p><strong>Ø</strong> <strong>单例模式</strong>：在内存中，保证对象的实例只有一个。</p>
<p>Ø 装饰者模式：对一个类进行装饰，增强其方法行为，如Java中的IO流就使用了装饰者模式</p>
<p><strong>Ø</strong> <strong>代理模式</strong>：比如sping AOP使用动态代理</p>
<p>Ø 适配器模式：io流，通过继承实现将一个接口适配到另一个接口，InputStreamReader类继承Reader接口，但要创建它们必须在构造函数中传入一个InputStream的实例，InputStreamReader的作用也就是将InputStream适配到Reader</p>
<p>Ø 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<h4 id="2-单例设计模式中懒汉式和饿汉式的区别"><strong>2.</strong> <strong>单例设计模式中懒汉式和饿汉式的区别</strong></h4>
<p>l 饿汉式：</p>
<p><a target="_blank" rel="noopener" href="//xn--fsq25gkxn7jnn8siz3b.xn--7brpxu1hg9cbzvg15a">//饿汉式单例类.在类初始化时</a>，已经自行实例化</p>
<p>public class Singleton1 {</p>
<p>​    private Singleton1() {}</p>
<p>​    private static final Singleton1 single = new Singleton1();</p>
<p>​    //静态工厂方法</p>
<p>​    public static Singleton1 getInstance() {</p>
<p>​        return single;</p>
<p>​    }</p>
<p>}</p>
<p>l 懒汉式：</p>
<p><a target="_blank" rel="noopener" href="//xn--fsq25gkxn1wczws3ux.xn--4gq80bfmx2h0wg3uhclee6tg4kpiznndu4smlv1j6a">//懒汉式单例类.在第一次调用的时候实例化自己</a></p>
<p>public class Singleton {</p>
<p>​    private Singleton() {}</p>
<p>​    private static Singleton single=null;</p>
<p>​    //静态工厂方法</p>
<p>​    public static Singleton getInstance() {</p>
<p>​         if (single == null) {</p>
<p>​             single = new Singleton();</p>
<p>​         }</p>
<p>​        return single;</p>
<p>​    }</p>
<p>}</p>
<p>l 饿汉式就是类一旦加载，就把单例初始化完成，保证getInstance()的时候，单例就已经存在。</p>
<p>l 懒汉式比较懒，只有当调用getInstance的时候，才会去初始化这个单例</p>
<p>区别：</p>
<p>l 饿汉式是线程安全的，懒汉式是线程不安全的（即一个进程内有多个线程在在同时使用时可能会产生多个实例，可创建个静态内部类，产生一个单例对象，通过静态内部类返回获取这个对象）</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1712870063861265422&amp;wfr=spider&amp;for=pc">单例设计模式精讲 (baidu.com)</a></p>
<p>总结：能说出两三个以上的设计模式，重点掌握工厂和单例设计模式。</p>
<h1><strong>二、</strong> <strong>WEB</strong></h1>
<p><strong>1.</strong> <strong>cookie和session的区别与联系【必须】</strong></p>
<p>一、cookie数据存放在客户的浏览器上,session数据存放在服务器上.</p>
<p>二、很多浏览器限制站点最多保存20个cookie,单个cookie保存的数据不能超过4k.</p>
<p>三、cookie不是很安全,考虑安全应当使用session.</p>
<p>四、可以考虑将登录信息等重要信息存放为session,其它信息如果需要保留,可以放在cookie中.</p>
<p>五、session会在一定时间内保存在服务器上.</p>
<p>六、session会在浏览器关闭或者一段时间内销毁,也可以通过setMaxInactiveInterval(int)方法进行设置,或是通过invalidate()方法强制结束当前会话.cookie可以通过setMaxAge(int)方法设置缓存在客户端的时间.</p>
<p>七、一般情况下,session生成的sessionid都是保存在cookie中.</p>
<p><strong>总结:</strong></p>
<p><strong>cookie:在客户端保存数据,不安全.只能保存字符串,且是少量数据.</strong></p>
<p><strong>session:在服务器端保存数据,安全.可以保存对象数据,数据无限制.</strong></p>
<p>Session是基于cookie的，session的id是存在cookie中的</p>
<p><strong>2.</strong> <strong>如果客户端禁止cookie，session 还能用吗？【必须】</strong></p>
<p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>
<p>url重写！！</p>
<p><strong>3.</strong> <strong>Get方法和Post方法区别【必须】</strong></p>
<p>get:查询、请求参数 不安全,提交的数据量小</p>
<p>post:添加或更新数据、提交数据比较安全、提交的数据量无限制.</p>
<p>一、get方法用于信息获取,他是安全的,而post方法是用于修改服务器上资源的请求.</p>
<p>二、get请求的数据会附在url之后,而post方法提交的数据则放置在http报文实体的主体里,所以post方法的安全性比get方法要高.</p>
<p>三、get方法传输的数据量一般限制在2kb,post方法对于数据大小是无限制的.</p>
<p><strong>4.</strong> <strong>servlet的生命周期及常用方法</strong></p>
<p>l init()方法:在servlet的生命周期中,仅执行一次init()方法.</p>
<p>l service()方法:它是servlet的核心,每当客户请求一个httpservlet对象,该对象的service()方法就要调用,而且传递给这个方法一个”请求”对象和一个”响应”对象作为参数.</p>
<p>l destory()方法:仅执行一次,在服务器端停止且卸载servlet时执行该方法.</p>
<p>解决servlet线程安全</p>
<p>一、继承SingleThreadModel,消耗服务器内存,降低性能.并且过时,不推荐.</p>
<p>二、尽量避免使用全局变量,推荐.</p>
<p>三、通过使用ThreadLocal.</p>
<p><strong>5.</strong> <strong>过滤器有哪些作用，以及过滤器的生命周期？【必须】</strong></p>
<p>生命周期：每个Filter在tomcat启动时进行初始化，每个Filter只有一个实例对象</p>
<p>l Init:在服务器启动时会创建Filter实例</p>
<p>l doFilter:这个方法会在用户每次访问“目标资源”时执行</p>
<p>l destroy():服务器关闭时销毁Filter对象</p>
<p>作用：</p>
<p>l 验证客户是否来自可信网络</p>
<p>l 对客户提交的数据进行重新编码</p>
<p>l 过滤掉客户的某些不应该出现的词汇</p>
<p>l 验证用户是否可以登录</p>
<p>l 验证客户的浏览器是否支持当前的应用</p>
<p>l 记录系统日志</p>
<p><strong>6.</strong> <strong>转发和重定向的区别</strong></p>
<p>一、重定向是浏览器发送请求并收到响应以后再次向一个新地址发请求;转发是服务器收到请求后为了完成响应转到另一个资源.</p>
<p>二、重定向中有两次请求对象,不共享数据;转发只产生一次请求对象且在组件间共享数据.</p>
<p>三、重定向后地址栏地址改变,而转发不会.</p>
<p>四、重定向的新地址可以是任意地址;转发必须是同一个应用内的某个资源.</p>
<p>获取servlet的转发和响应重定向的方式</p>
<p>l 转发的方法:</p>
<p>通过HttpServletRequest的getRequestDispatcher()方法获得</p>
<p>通过ServletContext的getRequestDispatcher()方法获得</p>
<p>l 重定向的方法:</p>
<p>HttpServletResponse的sendRedirect()方法.</p>
<p><strong>7.</strong> <strong>ajax书写方式及内部主要参数</strong></p>
<p>主要参数:</p>
<p>一、url:要求为String类型的参数,发送请求的地址.</p>
<p>二、data:要求为Object或String类型,发送到服务器的数据.</p>
<p>三、type:要求为String类型,请求方式get或post.</p>
<p>四、datatype:要求为String类型,预期服务器返回的类型.</p>
<p>五、timeout:要求为number类型,设置请求超时时间.</p>
<p>六、async:要求为boolean类型,异步为true(默认),同步为false.</p>
<p>七、cache:要求为boolean类型,默认为true,是否从浏览器缓存中加载信息.</p>
<p>八、beforesend:要求为Function类型的参数.例如添加自定义http头.</p>
<p>ajax的优缺点:</p>
<p>l 优点:减轻服务器的负担,按需取数据,最大程度的减少冗余请求,局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验.</p>
<p>l 缺点:ajax大量的使用了JavaScript和ajax引擎,这些取决于浏览器的支持,在编写的时候考虑对浏览器的兼容性.ajax只是局部刷新,所以页面的后退按钮是没有用的.</p>
<p><strong>8.</strong> <strong>Jquery常用选择器</strong></p>
<p>Jquery选择器总共有四大类:</p>
<p>基本选择器、层级选择器、过滤选择器和表单选择器.</p>
<p>l 基本选择器是Jquery最常用的选择器,也是最简单的选择器,他通过元素id,class和标签名来查找dom元素.</p>
<p>l 层级选择器是通过dom元素间的层次关系来获取元素,主要层次关系包括父子、后代、相邻、兄弟关系.</p>
<p>l 过滤选择器主要是通过特定的过滤规则筛选出所需的dom元素,过滤规则与css中的伪类选择器语法相同,即选择器都以一个冒号开头.</p>
<p>一、Jquery基本过滤选择器</p>
<p>二、Jquery内容过滤选择器</p>
<p>三、Jquery可见性过滤选择器</p>
<p>四、Jquery属性过滤选择器</p>
<p>五、Jquery子元素过滤选择器</p>
<p>六、Jquery表单对象属性过滤选择器</p>
<p>l 表单选择器:我们可以极其方便的获取表单的某个或某类型的元素.</p>
<p><strong>9.</strong> <strong>JSP和Servlet的区别</strong></p>
<p>l 什么是JSP:Java Server Pages(Java服务器端页面)动态页面</p>
<p>它和servlet技术一样,都是SUN公司定义的一种用于开发动态web资源的技术.</p>
<p>jsp=html+java</p>
<p>l jap执行原理</p>
<p>.jsp(翻译)–&gt;.java(编译)–&gt;.class(执行)</p>
<p>servlet:服务器端的小应用程序.适合编写java逻辑代码.</p>
<p>jsp:适合编写输出动态内容,但不适合编写java逻辑.</p>
<p><strong>10.</strong> <strong>JSP常用的标签</strong></p>
<p>l 请求转发：<a href="jsp:forward">jsp:forward</a></p>
<p>l 页面传递数据：<a href="jsp:param">jsp:param</a></p>
<p>l 输出标签：&lt;c:out&gt;</p>
<p>l 判读标签&lt;c:if&gt;</p>
<p>l 迭代标签&lt;c:foreach&gt;</p>
<p>l 多重判断标签&lt;c:choose&gt;</p>
<p>静态包含包含的是内容,动态包含包含的是结果.</p>
<p>静态包含不可以传递参数,而动态包含可以传递参数.</p>
<p><strong>11.</strong> <strong>jsp九大内置对象及作用</strong></p>
<p>l PageContext 	JSP的页面容器</p>
<p>l request 		获取用户的请求信息</p>
<p>l response 		服务器向客户端的回应信息</p>
<p>l session 		用来保存每一个用户的信息</p>
<p>l application 		表示所有用户的共享信息</p>
<p>l config 			服务器配置信息，可以取得初始化参数</p>
<p>l out 				页面输出</p>
<p>l page 			但前页面对象，可以获取其他对象</p>
<p>l exception 		异常对象</p>
<p><strong>12.</strong> <strong>JSP四大作用域及请求范围</strong></p>
<p>JSP四大作用域从小到大分别为:page,request,session,application.</p>
<p>l 第一个作用域是page,他只在当前页面有效,也就是用户的请求页面有效.</p>
<p>l 第二个作用域是request,他在当前第一次请求中有效.</p>
<p>l 第三个作用域是session,他在当前整个会话中有效.</p>
<p>l 第四个作用域是application,他在整个应用都有效.</p>
<p>PageContext:pageContext 存放的数据在当前页面有效.开发时使用较少.</p>
<p>ServletRequest:request 存放的数据在第一次请求(转发)中有效.使用非常多.</p>
<p>HttpSession:session 存放的数据在第一次会话中有效.使用的比较多.如存放登录信息,购物车</p>
<p>ServletContext:application 存放的数据在整个应用范围都有效.因为范围太大,应尽量少用.</p>
<p><strong>13.</strong> <strong>如何防止表单重复提交</strong></p>
<p>网络延迟时,重复点击提交按钮,有可能发生重复提交表单问题.</p>
<p>解决方案:</p>
<p>一、数据库主键唯一.</p>
<p>二、提交成功后重定向.</p>
<p>三、使用JavaScript解决,使用标记位,提交后隐藏或不可用提交按钮.</p>
<p>使用session解决:</p>
<p>生成唯一的Token(uuid)给客户端,客户端第一次提交时带着这个Token,后台与session中的进行对比.</p>
<p><strong>14.</strong> <strong>常见的http返回状态码【必须】</strong></p>
<p>100:告诉客户端应继续发送请求</p>
<p>200:请求响应成功</p>
<p>202:请求已被受理还未做出响应</p>
<p>301：永久重定向</p>
<p>302：暂时重定向</p>
<p>400:请求无效,常见的情况是请求参数有误,http头构建错误</p>
<p>404:访问不到资源</p>
<p>500:服务器后端错误</p>
<p>1开头的状态码是消息类型的.</p>
<p>2开头的状态码表示成功.</p>
<p>3开头的状态码表示需要重定向.</p>
<p>4开头的状态码表示请求错误.</p>
<p>5开头的状态码表示服务器错误.</p>
<p><strong>15.</strong> <strong>TCP和UDP的区别,HTTP协议【必须】</strong></p>
<p>l TCP协议提供安全可靠的网络传输服务,它是一种面向连接的服务.类似于打电话,必须先拨号.双方建立一个传递信息的通道传输.</p>
<p>l UDP协议是一种数据报协议,它传输的数据是分组报文,它是无连接的,不需要和目标通信方建立连接,类似于写信,所以它的传输不保证安全可靠.但适合大数据量的传输.</p>
<p>l HTTP协议是超文本传输协议,是一种相对于TCP来说更细致的协议,TCP以及UDP协议规范的是网络设备之间的通信规范,HTTP实在TCP协议的基础上针对用户的协议,用户服务具体体现在应用程序之间的交互,比如javaweb中客户端服务端体系就要用http协议来规范通信.</p>
<p>TCP和UDP在开发中很少见到,但是网络底层都有他们的影子,正常的会话级别的服务:如客户端服务器体系底层就说基于TCP协议.而邮件发送,短信发送等底层使用的是UDP协议.</p>
<p>HTTP协议,客户端/服务器体系的程序都使用HTTP协议来规范通信.</p>
<p><strong>16.</strong> <strong>tcp为什么要三次握手，两次不行吗？为什么？</strong></p>
<p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>
<p><strong>17.</strong> <strong>说一下 tcp 粘包是怎么产生的？</strong></p>
<p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>
<p>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；<br>
接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</p>
<p><strong>18.</strong> <strong>json的数据格式</strong></p>
<p>l Json的最初出现是专门为JavaScript准备的,它是一种轻量级的数据交换格式.</p>
<p>(1) 数据在名称/值对中;</p>
<p>(2) 数据由逗号隔开;</p>
<p>(3) 花括号保存对象</p>
<p>{”属性名”:”值”,”属性名”:”值”}</p>
<p>l Json对象数组:</p>
<p>[{”属性名”:”值”,”属性名”:”值”},{”属性名”:”值”,”属性名”:”值”}]</p>
<p>l 复杂格式:</p>
<p>{”属性名”:”值”,”属性名”:{”属性名”:”值”}}</p>
<p>json中的值是有限制的,对于简单类型来说,只能是字符串,数值(必须是十进制)、布尔值和null;对于复合类型来说,只能放数组或者对象,不能是正则、函数或者日期;</p>
<p>json在网络开发中有非常广泛的用途,但可以归纳为一句:可以用于接口开发及调用中使用的数据格式.一来用于服务端和JavaScript之间的数据交互,二来可以用于跨域传输数据的数据格式.</p>
<p>在项目中,前后端交互、接口开发中很多都使用json来作为数据传输格式.</p>
<p><strong>19.</strong> <strong>如何实现跨域？【必须】</strong></p>
<p>n 服务器端运行跨域 设置 CORS 等于 *；</p>
<p>n 在单个接口使用注解 @CrossOrigin 运行跨域；</p>
<p>l 使用 jsonp 跨域,JSONP 实现原理:</p>
<p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>
<p>总结：站在后端角度出发，在微服务角度来说，跨域需要在网关层面解决，只需要配置即可。</p>
<p>使用的是CORS解决方案！！</p>
<p><strong>20.</strong> <strong>Tomcat体系结构讲解【3年左右】</strong></p>
<p>Tomcat 或者 Jetty 就是一个“HTTP 服务器 + Servlet 容器”，我们也叫它们 Web 容器。</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps9.jpg)</p>
<p>Web服务器需要实现两个核心功能：</p>
<p>l 处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</p>
<p>l 加载和管理 Servlet，以及具体处理 Request 请求。</p>
<p>因此 Tomcat 设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理。</p>
<p>可参考：<a target="_blank" rel="noopener" href="http://www.sohu.com/a/321678611_120176035">http://www.sohu.com/a/321678611_120176035</a></p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps10.jpg)</p>
<p>(1) Server<br>
Server表示整个的Catalina Servlet容器。Tomcat提供了Server接口的一个默认实现，这通常不需要用户自己去实现。在Server容器中，可以包含一个或多个Service组件。<br>
(2) Service<br>
Service是存活在Server内部的中间组件，它将一个或多个连接器（Connector）组件绑定到一个单独的引擎（Engine）上。在Server中，可以包含一个或多个Service组件。Service也很少由用户定制，Tomcat提供了Service接口的默认实现，而这种实现既简单又能满应用。<br>
(3) Connector<br>
连接器（Connector）处理与客户端的通信，它负责接收客户请求，以及向客户返回响应结果。在Tomcat中，有多个连接器可以使用。<br>
(4) Engine<br>
在Tomcat中，每个Service只能包含一个Servlet引擎（Engine）。引擎表示一个特定的Service的请求处理流水线。作为一个Service可以有多个连接器，引擎从连接器接收和处理所有的请求，将响应返回给适合的连接器，通过连接器传输给用户。用户允许通过实现Engine接口提供自定义的引擎，但通常不需要这么做。<br>
(5) Host<br>
Host表示一个虚拟主机，一个引擎可以包含多个Host。用户通常不需要创建自定义的<br>
Host，因为Tomcat给出的Host接口的实现（类StandardHost）提供了重要的附加功能。<br>
(6) Context<br>
一个Context表示了一个Web应用程序，运行在特定的虚拟主机中。什么是Web应用程序呢？在Sun公司发布的Java Servlet规范中，对Web应用程序做出了如下的定义：“一个Web应用程序是由一组Servlet、HTML页面、类，以及其他的资源组成的运行在Web服务器上的完整的应用程序。它可以在多个供应商提供的实现了Servlet规范的Web容器中运行”。一个Host可以包含多个Context（代表Web应用程序），每一个Context都有一个唯一的路径。用户 通 常 不 需 要 创 建 自 定 义 的 Context ， 因 为 Tomcat 给 出 的 Context 接 口 的 实 （ 类StandardContext）提供了重要的附加功能。凡是实现了Servlet规范的都可以成为Servlet容器</p>
<p><strong>21.</strong> <strong>tomcat 如何调优，涉及哪些参数</strong>**【3年左右】**</p>
<p>硬件上选择，操作系统选择，版本选择，jdk选择，配置jvm参数，配置connector的线程数量，开启gzip压缩，trimSpaces，集群等<br>
可参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com?t=http://blog.csdn.net/lifetragedy/article/details/7708724">http://blog.csdn.net/lifetragedy/article/details/7708724</a></p>
<h1><strong>三、</strong> <strong>数据库【必须】</strong></h1>
<p><strong>1.</strong> <strong>事务的特性和隔离级别</strong></p>
<p>事务的特性：</p>
<p>l 原子性（Atomicity）</p>
<p>​	原子性指事务是不可分割的工作单位，事务中的操作要么都发生，要么都不发生</p>
<p>l 一致性（Consistency）</p>
<p>​		事务必须使数据库从一个一致性状态变换到另外一个一致性状态</p>
<p>l 隔离性（Isolation）</p>
<p>​	事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>l 持久性（Durability）</p>
<p>​		持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>隔离级别：</p>
<p>l 未提交读read uncommitted</p>
<p>​		会发生 脏读、不可重复读、虚读</p>
<p>l 已提交读read committed			//Oracle   	SQL Server（系统事务）</p>
<p>​		解决脏读，但是不可重复读和虚读有可能发生</p>
<p>l 重复读repeatable read		//Mysql</p>
<p>​		解决脏读和不可重复读，但是虚读有可能发生.</p>
<p>l 串行化serializable</p>
<p>​		避免脏读，不可重复读，虚读的发生</p>
<p>不考虑隔离性会产生的问题：</p>
<p>l 脏读：脏读是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。</p>
<p>l 不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了</p>
<p>l 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。</p>
<p><strong>2.</strong> <strong>Mysql的体系结构</strong></p>
<p>l 连接层</p>
<p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通 信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证 它所具有的操作权限。</p>
<p>l 服务层</p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部 解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是 select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>l 引擎层</p>
<p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，</p>
<p>l 存储层 服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
<p>数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互。和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps11.jpg)</p>
<p><strong>3.</strong> <strong>InnoDB，MyISAM存储引擎特性</strong></p>
<p>l InnoDB</p>
<p>InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。 但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
<p>l MyISAM</p>
<p>MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表 。</p>
<p><strong>4.</strong> <strong>CHAR和<strong><strong>VARCHAR</strong></strong>的区别：</strong></p>
<p>Ø CHAR和VARCHAR类型在存储和检索方面有所不同</p>
<p>Ø CHAR列长度固定为创建表时声明的长度，长度值范围是1到255</p>
<p>Ø 当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p>
<p><strong>5.</strong> <strong>delete、drop、truncate****区别</strong></p>
<p>l truncate 和 delete只删除数据，不删除表结构 ,drop删除表结构，并且释放所占的空间。</p>
<p>l 删除数据的速度，drop&gt; truncate &gt; delete</p>
<p>l delete属于DML语言，需要事务管理，commit之后才能生效。drop和truncate属于DDL语言，操作立刻生效，不可回滚。</p>
<p>l 使用场合：</p>
<p>Ø 当你不再需要该表时， 用 drop;</p>
<p>Ø 当你仍要保留该表，但要删除所有记录时， 用 truncate;</p>
<p>Ø 当你要删除部分记录时（always with a where clause), 用 delete.</p>
<p><strong>6.</strong> <strong>mysql 中 in 和 exists 区别</strong></p>
<p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>
<p>如果查询的两个表大小相当，那么用in和exists差别不大。<br>
如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：<br>
not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。<br>
1.EXISTS只返回TRUE或FALSE，不会返回UNKNOWN。</p>
<p>2.IN当遇到包含NULL的情况，那么就会返回UNKNOWN。</p>
<p><strong>7.</strong> <strong>数据库的三范式是什么？【了解】</strong></p>
<p>l 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>l 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>l 第三范式：任何非主属性不依赖于其它非主属性。</p>
<p><strong>8.</strong> <strong>Sql优化</strong></p>
<p><strong>总体方针：</strong></p>
<p>Ø 通过慢查询日志去寻找，哪些sql执行效率低。Mysql会将那些查询慢【时间阈值】的sql记录下来。</p>
<p>Ø 使用explain分析低效率的sql执行计划</p>
<p>Ø 针对低效率的sql执行计划分析</p>
<p>没有索引</p>
<p>索引失效</p>
<p>数据量太大</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps12.jpg)</p>
<p><strong>情形一、没有索引：</strong></p>
<p>l 针对查询的列创建索引，提高查询效率，但是索引太多，mysql也会出现选择困难，所以建立索引要有效，无效的索引需要删除。</p>
<p>策略：</p>
<p>Ø 针对那些经常用于where条件查询的字段构建索引，针对进程排序的字段也可以构建索引。</p>
<p>Ø 尽量选择较小的列</p>
<p>Ø 将where中用的比较频繁的字段建立索引</p>
<p><strong>情形二、索引失效：</strong></p>
<p>Ø select子句中避免使用‘*’</p>
<p>Ø 避免在索引列上使用计算，not，in和&lt;&gt;等操作</p>
<p>Ø 当只需要一行数据的时候使用limit 1</p>
<p>Ø 保证表单数据不超过200w，适时分割表</p>
<p>Ø 针对查询较慢的语句，可以使用explain来分析该语句具体的执行情况</p>
<p>Ø 避免查询时判断null，否则可能会导致全表扫描，无法使用索引;</p>
<p>Ø 避免like查询，否则可能导致全表扫描，可以考虑使用全文索引</p>
<p>Ø 能用union all的时候就不用union，union过滤重复数据要耗费更多的CPU资源</p>
<p>数据量太大：</p>
<p>l 分页查询优化</p>
<p>l 在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<p>select * from table t where <a target="_blank" rel="noopener" href="http://t.id">t.id</a> in（select id from table order by id limit 100000，10） ;</p>
<p>l 对于主键自增的表，可以把limit查询缓存某个位置的查询</p>
<p>Select * from table where id &gt; 100000 limit 10;</p>
<p>VS</p>
<p>Select * from table limit 100000,10</p>
<p>分库分表：</p>
<p>l 使用MyCat中间件实现。</p>
<p>全文索引技术：</p>
<p>l ElasticSearch ， solr</p>
<p>非关系型数据库：</p>
<p>l 不需要像关系型数据库一样维护表于表之间的关系，而是使用json这种灵活多变的形式，效率比Mysql提高很多</p>
<p><strong>9.</strong> <strong>分库分表方案</strong></p>
<p>l 一开始上来就是32个库，每个库32个表，1024张表这个分法，</p>
<p>基本上国内的互联网肯定都是够用了</p>
<p>无论是并发支撑还是数据量支撑都没问题</p>
<p>l 如果每个库正常承载的写入并发量是1000，那么32个库就可以承载32 * 1000 = 32000的写并发，如果每个库承载1500的写并发，32 * 1500 = 48000的写并发，接近5万/s的写入并发，前面再加一个MQ，削峰，每秒写入MQ 8万条数据，每秒消费5万条数据。1024张表，假设每个表放500万数据，在MySQL里可以放50亿条数据。每秒的5万写并发，总共50亿条数据，对于国内大部分的互联网公司来说都够了。</p>
<p>l 此方案最多可以扩展到32个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到1024个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是1024个表么。</p>
<p>服务器升级流程：</p>
<p>l 设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是32库 * 32表，对于大部分公司来说，可能几年都够了</p>
<p>l 路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表</p>
<p>l 扩容的时候，申请增加更多的数据库服务器，装好mysql，倍数扩容，4台服务器，扩到8台服务器，16台服务器</p>
<p>l 由dba负责将原先数据库服务器的库，迁移到新的数据库服务器上去，很多工具，库迁移，比较便捷</p>
<p>l 我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址</p>
<p>l 重新发布系统，上线，原先的路由规则变都不用变，直接可以基于2倍的数据库服务器的资源，继续进行线上系统的提供服务</p>
<p><strong>10.</strong> <strong>MySQL 索引是怎么实现的？</strong></p>
<p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<p><strong>11.</strong> <strong>Mysql支持的索引类型</strong></p>
<p>l index  ----  普通索引,数据可以重复，没有任何限制。</p>
<p>l unique   ---- 唯一索引,要求索引列的值必须唯一，但允许有空值；如果是组合索引，那么列值的组合必须唯一。</p>
<p>l primary key ---- 主键索引,是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值，一般是在创建表的同时创建主键索引。</p>
<p>l 组合索引 ----  在多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。</p>
<p>l fulltext ---- 全文索引,是对于大表的文本域：char，varchar，text列才能创建全文索引，主要用于查找文本中的关键字，并不是直接与索引中的值进行比较。</p>
<p><strong>12.</strong> <strong>索引失效问题</strong></p>
<p>7种引起索引失效的情境</p>
<p>l 如果条件中有or，即使其中有部分条件带索引也不会使用(这也是为什么尽量少用or的原因)，例子中user_id无索引。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p>
<p>l 对于复合索引，如果不使用前列，后续列也将无法使用，类电话簿。</p>
<p>l like查询是以%开头</p>
<p>l 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</p>
<p>l where 子句里对索引列上有数学运算，用不上索引</p>
<p>l where 子句里对有索引列使用函数，用不上索引</p>
<p>l 如果mysql估计使用全表扫描要比使用索引快,则不使用索引</p>
<p><strong>13.</strong> <strong>左连接 ，右连接，内连接和全外连接的4者区别</strong></p>
<p><strong>l</strong> <strong>left join （左连接）</strong>：返回包括左表中的所有记录和右表中连接字段相等的记录。</p>
<p>l right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。</p>
<p><strong>l</strong> <strong>inner join （等值连接或者叫内连接）</strong>：只返回两个表中连接字段相等的行。</p>
<p>l full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录[mysql不支持]。</p>
<p><strong>14.</strong> <strong>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</strong></p>
<p>l 表类型如果是 MyISAM ，那 id 就是 8。</p>
<p>l 表类型如果是 InnoDB，那 id 就是 6。<br>
InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<p><strong>15.</strong> <strong>说一下 MySQL 的行锁和表锁？【非必须】</strong></p>
<p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>
行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
<p><strong>16.</strong> <strong>说一下乐观锁和悲观锁？【非必须】</strong></p>
<p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<p><strong>17.</strong> <strong>高并发下，如何做到安全的修改同一行数据。</strong></p>
<p>使用悲观锁 悲观锁本质是当前只有一个线程执行操作，结束了唤醒其他线程进行处理。也可以缓存队列中锁定主键。</p>
<p><strong>18.</strong> <strong>数据库会死锁吗，举一个死锁的例子</strong></p>
<p>产生死锁的原因主要是：</p>
<p>（1）系统资源不足。<br>
（2）进程运行推进的顺序不合适。<br>
（3）资源分配不当等。</p>
<p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。</p>
<p>产生死锁的四个必要条件：</p>
<p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<p><strong>19.</strong> <strong>聚集索引和非聚集索引的区别</strong></p>
<p>聚簇索引就是索引和记录紧密在一起。<br>
非聚簇索引 索引文件和数据文件分开存放，索引文件的叶子页只保存了主键值，要定位记录还要去查找相应的数据块。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xishilife/article/details/120256375">(48条消息) 聚簇索引和非聚簇索引的区别_xishilife的博客-CSDN博客_聚簇索引和非聚簇索引的区别</a></p>
<p><strong>20.</strong> <strong>mysql数据碎片处理</strong></p>
<p>在长期的数据更改过程中, 索引文件和数据文件,都将产生空洞,形成碎片.我们可以通过一个nop操作(不产生对数据实质影响的操作), 来修改表.比如: 表的引擎为innodb , 可以 alter table xxx engine innodb。也可以使用optimize table 表名 来进行修复.</p>
<p>注意: 修复表的数据及索引碎片,就会把所有的数据文件重新整理一遍,使之对齐.这个过程,如果表的行数比较大,也是非常耗费资源的操作.所以不能频繁的修复.如果表的Update操作很频率,可以按周/月,来修复.</p>
<p>如果不频繁,可以更长的周期来做修复.</p>
<h1><strong>四、</strong> <strong>框架</strong></h1>
<h2 id="4-1、Spring"><strong>4</strong>**.1、Spring**</h2>
<h4 id="S-pring-有哪些主要模块？"><strong>S****pring 有哪些主要模块？</strong></h4>
<p>Ø spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</p>
<p>Ø spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</p>
<p>Ø spring dao：Data Access Object 提供了JDBC的抽象层。</p>
<p>Ø spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</p>
<p>Ø spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</p>
<p>Ø spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps13.jpg)</p>
<h4 id="IOC和DI【重点】"><strong>IOC和DI【重点】</strong></h4>
<p>l IOC(控制反转).将对在自身对象中的一个内置对象的控制反转,反转后不再由自己本身的对象进行控制这个内置对象的创建,而是由第三方系统去控制这个内置对象的创建.简单来说就是把本来在类内部控制的对象,反转到类外部进行创建后注入,不再由类本身进行控制,这就是IOC本质. 对象交由spring创建和管理！</p>
<p>l DI(依赖注入).自身对象中的内置对象是通过注入的方式进行创建.</p>
<p>l IOC和DI的关系.</p>
<p>​	ioc就是容器,di就是注入这一行为,那么di确实就是ioc的具体功能的实现.而ioc则是di发挥的平台和空间.所以说,ioc和di即是相辅相成的搭档.最重要的是,他们都是为了实现解耦而服务的.</p>
<p>l DI是如何实现的.</p>
<p>​	依赖注入可以通过setter方法注入、构造注入、接口注入三种方法来实现,Spring支持setter注入和构造器注入、@Autowired自动注入,通常使用构造器注入来注入必须的依赖关系,对于可选的依赖关系,则setter注入是更好的选择,setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象.</p>
<h4 id="Spring-AOP【重点】"><strong>Spring AOP【重点】</strong></h4>
<p>Spring AOP的面向切面编程【它可以在不改动原来代码的基础上对方法进行增强】,是面向对象编程的一种补充,用于处理系统中分布的各个模块的横切关注点,比如事务管理、日志、缓存、统一异常处理等.它是使用动态代理实现的,在内存中临时为增强某个方法生成一个AOP对象,这个对象包含目标对象的所有方法,在特定的切入点做了增强处理,并回调原来的方法.</p>
<p>Spring AOP的动态代理主要有两种方式实现,JDK动态代理和cglib动态代理.<strong>JDK动态代理</strong>通过反射来接受被代理的类,但是被代理的类必须<strong>实现接口</strong>,核心是InvacationHandler和Proxy类.cglib动态代理的类一般是没有实现接口的类,cglib是一个代码生成的类库,可以在运行时动态生成某个类的子类.所以,<strong>cglib是通过继承的方式</strong>做的动态代理,因此如果某个类被标记为final,那么它是无法使用cglib做动态代理的.</p>
<p>AOP能做什么:</p>
<p>l 降低模块的耦合度.</p>
<p>l 使系统容易扩展</p>
<p>l 避免修改业务代码,避免引入重复代码,更好的代码复用.</p>
<p>AOP怎么用:</p>
<p>l 前置通知:某方法调用前发出通知.</p>
<p>l 后置通知:某方法完成之后发出通知.</p>
<p>l 返回后通知:方法正常返回后,调用通知.在方法,正常退出发出通知.</p>
<p>l 异常通知:抛出异常后通知:在方法抛出异常退出时执行的通知.在方法调用时,异常退出发出通知.</p>
<p>l 环绕通知:通知包裹在被通知的方法的周围.</p>
<p>JDK动态代理：基于接口实现</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps14.jpg)</p>
<p>Cglib：基于extends继承</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps15.jpg)</p>
<h4 id="Spring中Bean的作用域"><strong>Spring中Bean的作用域</strong></h4>
<p>Spring IOC容器在根据配置创建一个Bean对象实例时,可以为Bean指定实例的作用范围.</p>
<p><strong>l</strong> <strong>singleton(单例模式)</strong></p>
<p>IOC容器仅创建一个Bean实例,IOC容器每次返回的是同一个Bean实例.</p>
<p><strong>l</strong> <strong>prototype(原型模式)</strong></p>
<p>IOC容器仅创建多个Bean实例,IOC容器每次返回的是一个新的实例.</p>
<p>l request(HTTP请求)</p>
<p>该属性仅对HTTP请求产生作用,每次HTTP请求都会创建一个新的Bean,适用于WebApplicationContext.</p>
<p>l session(会话)</p>
<p>该属性仅用于HTTP Session,同一个session共享一个Bean实例.不同session使用不同的实例.</p>
<p>l global-session(全局会话,在spring5.x中已移除)</p>
<p>该属性仅用于HTTP Session,同session作用域不同的时候,所有session共享一个Bean实例.</p>
<p>总结：基本使用的都是singletong，而且spring默认就是singleton。面试官可能会说这个singleton会不会存在并发线程安全问题，问题是存在的。但是在程序中是不存在这个类问题的。</p>
<h4 id="Spring框架实现实例化和依赖注入的方式"><strong>Spring框架实现实例化和依赖注入的方式</strong></h4>
<p>l 实例化:</p>
<p>一、构造器实例化Bean</p>
<p>二、静态工厂方式实例化Bean</p>
<p>三、实例工厂方式实例化Bean</p>
<p>l 依赖注入:</p>
<p>一、基于构造函数的注入</p>
<p>二、基于set方法的注入</p>
<p>三、基于自动装配的注入</p>
<p>四、基于注解的依赖注入</p>
<h4 id="Spring常用注解"><strong>Spring常用注解</strong></h4>
<p>l @Component:用于标记在一个类上,表示当前类是spring的一个组件,是ioc的一个容器.他有三个衍生注解:@Controller、@Service、@Repository</p>
<p>l @Controller：用于标记在一个类上,代表这个类是控制层组件.</p>
<p>l @Service:用于标记在一个类上,代表这个类是业务层组件.</p>
<p>l @Repository:用于标记在一个类上,代表这个类是数据访问层组件.、</p>
<p>l @Bean</p>
<p>l @Autowired</p>
<p>l @Value</p>
<p>l @Transactional:写在类上用于指定当前类中的方法支持事务,写在方法上表示当前的方法支持事务</p>
<h4 id="BeanFactory类图结构"><strong>BeanFactory类图结构</strong></h4>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps16.png)</p>
<p><strong>BeanFactory</strong> <strong>VS A****pplicationContext</strong></p>
<p><strong>所有的Bean在启动的时候都进行了加载</strong> <strong>A****pplicationContext</strong></p>
<p><strong>Bean在使用的时候才会加载</strong>  <strong>BeanFactory</strong></p>
<p><strong>BeanFactory【容器】</strong>  <strong>VS  F****actoryBean【创建bean放入容器】</strong></p>
<h4 id="SpringBean的生命周期"><strong>Spring<strong><strong>B</strong></strong>ean的生命周期</strong></h4>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps17.jpg)</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps18.jpg)</p>
<p><strong>总结：创建的时候执行初始化方法</strong> <strong>init-method</strong>**【<strong><strong>@PostConstruct</strong></strong>】，在容器销毁的时候，执行销毁方法destroy****-method****【@<strong><strong>PreDestroy</strong></strong>】**</p>
<h4 id="Spring-怎么解决循环依赖问题？【重要】"><strong>Spring 怎么解决循环依赖问题？【重要】</strong></h4>
<p>spring对循环依赖的处理有三种情况：</p>
<p>Ø 构造器的循环依赖：这种依赖spring是处理不了的，直 接抛出BeanCurrentlylnCreationException异常。</p>
<p>Ø 单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。</p>
<p>Ø 非单例循环依赖：无法处理。</p>
<h4 id="Spring-框架中用到了哪些设计模式？"><strong>Spring 框架中用到了哪些设计模式？</strong></h4>
<p>Ø 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</p>
<p>Ø 代理设计模式 : Spring AOP 功能的实现。</p>
<p>Ø 单例设计模式 : Spring 中的 Bean 默认都是单例的。</p>
<h4 id="Spring事务传播行为"><strong>Spring事务传播行为</strong></h4>
<p><strong>Ø</strong> <strong>PROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</strong></p>
<p>Ø PROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
<p>Ø PROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。</p>
<p><strong>Ø</strong> <strong>PROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。</strong></p>
<p>Ø PROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>Ø PROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>Ø PROPAGATION_NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
<h2 id="4-2、Spring-MVC"><strong>4</strong>**.2、Spring****MVC**</h2>
<h4 id="SpringMVC-执行流程"><strong>S<strong><strong>prin</strong></strong>gMVC****执行流程</strong></h4>
<ol>
<li>
<p>用户发送请求至前端控制器DispatcherServlet</p>
</li>
<li>
<p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
</li>
<li>
<p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
</li>
<li>
<p>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p>
</li>
<li>
<p>HandlerAdapter执行处理器(handler，也叫后端控制器)。</p>
</li>
<li>
<p>Controller执行完成返回ModelAndView</p>
</li>
<li>
<p>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</p>
</li>
<li>
<p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p>
</li>
<li>
<p>ViewReslover解析后返回具体View对象</p>
</li>
<li>
<p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p>
</li>
<li>
<p>DispatcherServlet响应用户</p>
</li>
</ol>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps19.jpg)</p>
<h4 id="SpringMVC常用注解"><strong>SpringMVC常用注解</strong></h4>
<p>Ø @RequestMapping:是一个用于处理请求地址映射的注解,可用于类或方法上.用于类上,表示类中所有响应请求的方法都是以该地址作为父路径</p>
<p>Ø @RequestParam:用于将指定的请求参数赋给方法中的形参.</p>
<p>Ø @PathVariable:可以获取URL中的动态参数.</p>
<p>Ø @RequestBody:用于读取request请求的body部分数据.</p>
<p>Ø @ResponseBody:用于将controller方法返回的对象,用流响应给客户端.</p>
<p>Ø @RestController:@Controller+@ResponseBody,用于标记在一个类上.</p>
<h4 id="springmvc获取参数的几种方式"><strong>springmvc获取参数的几种方式</strong></h4>
<p>l 借助原始ServletAPI的HttpServletRequest对象.</p>
<p>Controller的方法,</p>
<p>添加HttpServletRequest类型入参,</p>
<p>通过HttpServletRequest.getParameter()获取请求数据</p>
<p>l 借助控制器方法的形参</p>
<p>controller的方法,添加参数来接收表单的数据.</p>
<p>接收的类型包括:</p>
<p>一、基本类型或String</p>
<p>二、实体类类型</p>
<p>三、实体类关联对象</p>
<p>l Controller方法,接收实体类类型参数,而表单提交的是json数据时,可以使用@RequestBody注解获取全部请求体,配合jackson开源组件可以实现转换成实体类.要求json数据的key必须和实体类属性保持一致.</p>
<h4 id="Spring-MVC的异常处理-？"><strong>Spring MVC的异常处理 ？</strong></h4>
<p>Ø 编写异常处理类@ControllerAdvice/@RestControllerAdvice  +  在类中编写异常处理方法@ExceptionHandler(Exception.class)</p>
<p>Ø 编写异常处理类实现接口 HandlerExceptionResolver</p>
<h4 id="S-pringmvc文件上传？"><strong>S****pringmvc文件上传？</strong></h4>
<p>MultipartFile 接收文件  -&gt;  FileUpload提供api去做的 -&gt; request的请求体</p>
<p>设置文件大小：</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps20.jpg)</p>
<h4 id="SpringMVC拦截器？"><strong>SpringMVC拦截器？</strong></h4>
<p>HandlerInterceptor 接口！！</p>
<h2 id="4-3、Springboot"><strong>4</strong>**.3、Springboot**</h2>
<h4 id="spring-boot-有哪些方式可以实现热部署？"><strong>spring boot 有哪些方式可以实现热部署？</strong></h4>
<p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；<br>
使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p>
<h4 id="SpringBoot-的常用注解有哪些？"><strong>SpringBoot 的常用注解有哪些？</strong></h4>
<p>@SpringBootApplication:</p>
<p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan通常用在主类上；</p>
<p>@ComponentScan:组件扫描。个人理解相当于，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean*；<br>
@Configuration:指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上；</p>
<p>@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理；</p>
<p>@Import：用来导入其他配置类。</p>
<p>@ImportResource：用来加载xml配置文件。</p>
<p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。</p>
<p>@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p>
<h4 id="SpringBoot-有哪几种读取配置的方式？"><strong>SpringBoot 有哪几种读取配置的方式？</strong></h4>
<p>方式一： 通过@Value(“${spring.datasource.url}”)这样的方式读取<br>
方式二：通过@ConfigurationProperties(prefix = “spring.datasource”)这种写法系统会依据prefix前缀自动注入配置数据到数据实体变量,这种方式不错,但是存在缺陷,我们编写的PropertyPlaceholderConfigurer扩展字段会无效,所以如果只是单纯的读取配置而不需要额外操作时可使用这方式最简单</p>
<p>方式三： 我们可以直接注入Environment对象示例并读取properties对象属性environment.getProperty(“spring.datasource.database”);与方式一的本质差不多,我们不需要编写对应字段的模型对象,但是对于程序可阅读性不好友,复用率不高</p>
<p>方式四： 通过系统启动时候初始化Listener,使用PropertiesLoaderUtils工具类读取指定配置文件并获得Properties配置对象,我们可以随时随地使用该对象的属性,这种方式比较少用,针对比较自定义的配置数据可使用该方式</p>
<h4 id="SpringBoot-配置加载顺序？"><strong>SpringBoot 配置加载顺序？</strong></h4>
<p>在不指定要被加载文件时，默认的加载顺序：由里向外加载，所以最外层的最后被加载，会覆盖里层的属性，加载顺序依次为：</p>
<p>l 位于与jar包同级目录下的config文件夹，</p>
<p>l 位于与jar包同级目录下</p>
<p>l idea 环境下，resource文件夹下的config文件夹</p>
<p>l idea 环境下，resource文件夹下  （1-&gt;4, 外-&gt;里）</p>
<h4 id="Spring-Boot-如何定义多套不同环境配置"><strong>Spring Boot 如何定义多套不同环境配置</strong></h4>
<p>一、Spring Boot 环境设置机制</p>
<p>spring.profiles.active 属性可以为我们指定当前设置的环境，以此来选择我们的配置文件。例如我们有配置文件</p>
<p>application.yml</p>
<p>application-dev.yml</p>
<p>application-test.yml</p>
<p>application-prod.yml</p>
<p>当执行 java -jar xxx.jar --spring.profiles.actvie=test 此时，系统将启用 application.yml 和 application-test.yml配置文件。</p>
<p>当执行 java -jar xxx.jar --spring.profiles.actvie=prod 此时，系统将启用 application.yml 和 application-prod.yml 配置文件。</p>
<p>二、配置多环境</p>
<p>正如 第一 点所述，我们配置不同的配置文件</p>
<p>application.yml</p>
<p>application-dev.yml（开发环境）</p>
<p>application-test.yml（测试环境）</p>
<p>application-uat.yml（预发布环境）</p>
<p>application-prod.yml（生产环境）</p>
<p>三、指定环境</p>
<p>1 在 cmd 命令中指定</p>
<p>java -jar xxx.jar --spring.profiles.actvie=dev</p>
<p>2 在 application.yml 中指定</p>
<p>spring:  profiles:    active: dev</p>
<h2 id="4-4、Mybatis-Mybatis-plus"><strong>4</strong>**.4、Mybatis&amp;Mybatis-plus**</h2>
<h4 id="Mybatis中使用-和-书写占位符有什么区别"><strong>Mybatis中使用#和$书写占位符有什么区别</strong></h4>
<p>#{}传参能防止sql注入.</p>
<p>${}传参是字符串拼接.</p>
<h4 id="动态SQL"><strong>动态SQL</strong></h4>
<p>l 所谓SQL的动态和静态,是指SQL语句在何时被编译和执行,二者都是用在SQL嵌入式编程中的.</p>
<p>l SQL语句的主体结构,在编译时尚无法确定,只有等到程序运行起来,在执行的过程中才能确定,这种SQL叫做动态SQL.</p>
<p>l 静态SQL语句的编译是在应用程序运行前进行的,编译的结果会存储在数据库内部.</p>
<p>l 程序运行时,数据库将直接执行编译好的SQL语句,降低运行时的开销.</p>
<p>l MyBatis中用于实现动态SQL的元素主要有:if、where、foreach.</p>
<h4 id="Mapper动态代理规范"><strong>Mapper动态代理规范</strong></h4>
<p>l xml映射文件中的namespace与mapper接口的全类名相同.</p>
<p>l mapper接口方法名和xml映射文件中定义的每个statement的id相同.</p>
<p>l mapper接口方法的输入参数类型和xml映射文件中定义的每个sql的parameterType的类型相同.</p>
<p>l mapper接口方法的输出参数类型和xml映射文件中定义的每个sql的resultType的类型相同.</p>
<p>l mybatis中的mapper动态代理是不支持方法重载的dao接口里的方法,因为是全类名+方法名的保存和寻找策略.</p>
<p>l mapper接口的工作原理是JDK动态代理,mybatis运行时就是用JDK动态代理为mapper接口生成代理proxy对象,代理对象proxy会拦截接口方法,转而执行mappedStatement所代表的sql,然后将sql执行结果返回.</p>
<h4 id="Mybatis常用注解"><strong>Mybatis常用注解</strong></h4>
<p>@Insert ： 插入sql , 和xml insert sql语法完全一样</p>
<p>@Select ： 查询sql, 和xml select sql语法完全一样</p>
<p>@Update ： 更新sql, 和xml update sql语法完全一样</p>
<p>@Delete ： 删除sql, 和xml delete sql语法完全一样</p>
<p>@Param ： 当映射器方法需要多个参数时，指定参数的名字</p>
<p>@Results ： 结果集合</p>
<p>@Result ： 结果</p>
<p>@One ：复杂类型的单独属性值映射</p>
<p>@Many ：复杂类型的己合属性映射</p>
<h1><strong>五、</strong> <strong>MQ消息队列</strong></h1>
<p><strong>1.为什么使用MQ?</strong></p>
<p>l 使用MQ的好处:解耦，异步，削峰平谷;</p>
<p>l 解耦：</p>
<p>l 当A系统生产关键数据,而且B,C,D系统需要A系统给它们发送数据,来进行下一步操作,此时A系统和BCD系统产生了严重的耦合,所有的操作和维护都要在A系统中进行,如果将A系统产生的数据放到MQ当中,让BCD系统需要的时候去消费,此时就解放了A系统,不用考虑调用成功,失败超时等情况,同时ABCD系统独立运行,后续新添加系统需要A系统的数据,也不需要去修改A系统的代码,达到了解耦的效果</p>
<p>l 异步：</p>
<p>l 一般互联网类企业,对用户的直接操作,一般要求每个请求在200ms以内完成。对于一个系统调用多个系统,在不适用mq的情况下,它执行完返回的耗时,是执行完所有系统所需时间的总和;使用mq进行优化后,执行的耗时,则是执行主系统的耗时,以及加上主系统发送数据到消息队列的耗时,大幅度提升高延时接口的性能,提升了用户体验.</p>
<p>l 削峰平谷：</p>
<p>l 一般MySQL的每秒请求最高在2000左右，用户访问量高峰期的时候涌入的大量请求,很可能将MySQL给打死,然后系统就挂掉,但是高峰期过了,请求量可能远远低于2000,所以这种情况去增加服务器就不值得,如果使用mq的情况,将用户的请求全部放到mq中,然后让系统去消费用户的请求,不要超过系统所能承受的最大请求数量,保证系统不会再高峰期挂掉,但此时可能有几十万或几百万请求积压在mq中,但是高峰期一过,系统还是按照最大请求数量进行处理请求,很快就能将积压请求处理完</p>
<p>​</p>
<p>l 使用MQ的缺陷:</p>
<p>l 系统可用性降低:以前只要担心系统的问题,现在还要考虑mq如果挂掉的问题,因为mq一旦挂掉,所关联的系统,就会统统挂掉</p>
<p>l 系统复杂性变高:考虑的问题变多,要考虑消息丢失,消息重复消费的情况</p>
<p>l 一致性问题:比如A系统调用BCD系统,BCD同时成功才能执行成功,返回数据,现在BC执行成功,D发生异常的情况,并没有执行成功,但是A给用户返回的是成功</p>
<p><strong>2.你了解哪些MQ技术，ActiveMQ,RabbitMQ,RocketMQ,<strong><strong>K</strong></strong>afka</strong></p>
<p>l ActiveMQ它可以支持万级的吞吐量,它是一个比较成熟完善的中间件,但是它存在有少量信息丢失的情况,而且目前官方对他的更新迭代不是很即时,社区的活跃度不是很高</p>
<p>l RabbitMQ是一款用Erlang语言开发的消息中间件,它延时低,唯一一款达到微妙级延时的消息中间件,而且社区活跃度高,对于bug问题的修复很及时,而且提供了很友善的后台界面,唯一的劣势是就是我们搞java开发的很少有人能够阅读它的源码,对于问题的修复仅仅依靠社区。</p>
<p>l RocketMQ是阿里旗下的一款品质优秀的MQ,它可以达到十万级的吞吐量,而且它还是支持分布式事务,应用于分布式架构,它的维护基本上都是靠阿里,如果哪天阿里宣布放弃这个项目的维护,除非你们公司有能力继续来维护RocketMQ的使用。</p>
<p>l Kafka也是一款分布式的中间件,最大优点就是其吞吐量高,一般运用于大数据系统的实时运算和日志采集的场景,功能简单,可靠性高,扩展性高,唯一的缺点是可能导致重复消费,但是这点轻微的影响在大数据场景下可以忽略。</p>
<p>​</p>
<p><strong>3.RabbitMQ 的使用场景有哪些？【项目中怎么用的】</strong><br>
抢购活动，削峰填谷，防止系统崩塌。</p>
<p>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</p>
<p>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p>
<p><strong>4.如何保证MQ的高可用?</strong></p>
<p>集群模式：普通集群、镜像集群或者仲裁队列。</p>
<p><strong>5.如何保证消息不被重复消费(如何保证消息消费时的幂等性)?</strong></p>
<p>从代码层面设计，多做判断，保证方法执行多次结果是一样的。</p>
<p>l 重复消费:</p>
<p>l 每个中间件它能够保证的是消息不丢失,但不能保证消息不被重复发送，所以接收方就要做幂等性的判断，防止消息重复消费，例如：支付金额的消息被消费了两次，那么所得到的钱数就是错误的，这种情况在系统中肯定是不允许存在的。</p>
<p>l 消费的幂等性（同样的操作，在一段时间内，只执行一次）:</p>
<p>l 如果是往数据库里写入数据,就根据主键查一下,如果数据已经存在,就update</p>
<p>l 可以在把数据先存在set或者redis中,消费前,先去里面查看,数据是否已存在,已存在就丢弃这数据,比如说我们的订单系统,生成订单也会用到mq,此时订单id就是全局唯一的id,在写入数据库之前,就可以先把数据去redis中查询,如果redis中已经存在,则不进行消费操作,如果redis中不存在的话,就存在redis中,然后进行下一步操作.</p>
<p>l 在数据库中设置唯一约束,就不会导致重复数据的多次插入</p>
<p>​</p>
<p><strong>5.</strong> <strong>如何保证消息不丢失</strong></p>
<p>三个角度分析问题：</p>
<p>生产者【publish comfirm+publish return】、</p>
<p>MQ中间件【持久化】、</p>
<p>消费者【ack】</p>
<p>l rabbitMQ:</p>
<p>l 消息丢失的情况:生产者写的消息在到中间件的网络传输过程中就丢了,或者是消息到了中间件,但是内部出错,消息没保存下来</p>
<p>l 中间件将消息保存下来,还没等到消费者消费完,就自己挂掉,导致消息丢失</p>
<p>l 消费者取到消息还没来得及消费就自己挂掉了,因为rabbitMQ消费者开启了autoAck,在消费数据还没成功时,就已经向中间件发送完成的信息,此时消费者挂掉,就会消息丢失</p>
<p>l 解决方案:</p>
<p>l 生产者消息丢失,可以通过开启事务功能,如果消息没有发送成功,发生异常就回滚,然后重试发送消息,发送成功就提交事务,这个的缺陷就是阻塞式的,降低吞吐量,耗费性能;如果是rabbitMQ可以开启confirm模式,它能给每次写的消息都分配一个唯一的id,如果写入到rabbitMQ中,rabbitMQ就会回传一个ack消息,如果没有就会会挑一个nack接口,告诉你消息接收失败,你可以重试,confrim机制是异步的,效率会高很多</p>
<p>l 关于中间件的数据丢失,可以开启中间件的持久化,将消息持久化磁盘中,中间件挂了恢复之后自动读取之前存储的数据.</p>
<p>l 消费者数据丢失,关闭rabbitMQ的autoACK机制,自己手动提交完成信息</p>
<p>​</p>
<p><strong>6.</strong> <strong>如何保证消息的顺序性</strong></p>
<p>l rabbitMQ为多个消费者开辟多个queue队列（先进先出）,将保证操作顺序的消息发布到同一个队列中去，操作这个队列的消费者会一个一个消息去处理，因为队列这种结构是先进先出的类型，所以保证的数据的顺序性。</p>
<p>​</p>
<p><strong>7.</strong> <strong>消息大量积压怎么解决？</strong></p>
<p>l 临时启动多个消息者，并发处理消息;</p>
<p>l 临时启动多个消息者，接受消息之后，不处理。暂时把消息写到文件中。消息中间件中的消息处理的完了。关闭临时消费者。单独写个离线程序，处理文件中的消息;</p>
<p>l 临时启动多个消息者，接受消息之后，直接丢弃。 可以让生产者的源头恢复数据;</p>
<p><strong>8.</strong> <strong>RabbitMQ 节点的类型有哪些？</strong></p>
<p>l 磁盘节点：消息会存储到磁盘。</p>
<p>l 内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p>
<p><strong>9.</strong> <strong>R****abbitmq如何确认消息一定发送到了消息中间件中呢?</strong></p>
<p>消息发送到server是先通过交换机,再到消息队列,只要数据到队列,那么此消息肯定是发送成功的.</p>
<p>​	第一步确定消息发送到了交换机.</p>
<p>使用发送方确认机制来判断消息是否发送成功.</p>
<p>​	第二步确认交换机把消息路由到消息队列.</p>
<p>使用失败回调来判断消息是否发送成功.</p>
<p>​	只有两步都成功,此消息才是发送成功的.</p>
<p><strong>10.</strong> <strong>rabbitmq的集群</strong></p>
<p>参考网站:docker中搭建rabbitmq集群-&gt; <a target="_blank" rel="noopener" href="https://www.cnblogs.com/vipstone/p/9362388.html">https://www.cnblogs.com/vipstone/p/9362388.html</a></p>
<p>​	集群分为普通集群和镜像集群.</p>
<p>​	普通集群: 普通集群,他会把所有节点的交换机信息和队列的元数据分为两种(队列数据分为两种: 一种为队列里面的消息,另一种是队列本身的信息, 后者被称为元数据.)进行复制,确保所有的节点都有一份.</p>
<p>​	镜像集群: 在普通集群的基础上,把所有的队列数据完全同步(对性能有一定的影响)当对数据可靠性要求高时,可以使用镜像模式.</p>
<p>​	镜像集群实现由两种方式:   一种是直接在管理台控制,</p>
<p>​							  一种是在声明队列的时候控制.</p>
<p>​	配置集群还设计到节点信息, 有内存节点和磁盘节点,如果对队列有修改的情况下,必须有磁盘节点,用来保存信息,内存节点断电后,信息就消失,无法保存. 默认就是磁盘节点, 设置 --ram为内存节点.</p>
<h1><strong>六、</strong> <strong>Redis</strong></h1>
<p><strong>1.</strong> <strong>使用redis缓存的好处</strong></p>
<p>l 提高并发量，不需要每次都访问数据库，提高并发量。</p>
<p>l 提高性能，redis运行在内存中，内存的执行效率，远远超过数据库。</p>
<p><strong>2.</strong> <strong>Redis的key和value的存储大小有限制吗？</strong></p>
<p>l Redis的key和value的存储大小都是有限制的，都是512M。</p>
<p><strong>3.</strong> <strong>redis存储什么数据类型</strong></p>
<p>(1) 字符串（String）</p>
<p>(2) 字符串列表（lists）</p>
<p>(3) 字符串集合（sets）</p>
<p>(4) 有序字符串集合（sorted sets）</p>
<p>(5) 哈希（hash）</p>
<p><strong>4.</strong> <strong>使用redis缓存的弊端【搁置】</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/QiuHaoqian/article/details/109154315">(44条消息) Redis 缓存穿透、缓存击穿、缓存雪崩_浩骞的博客-CSDN博客_redis缓存穿透</a></p>
<p>缓存穿透，大量的请求访问,查询的是数据库中不存在的数据,就会在缓存中无法命中,直接去访问数据库,数据库中也查询不到,自然无法将结果写入缓存,下一秒又有大量请求查询不存在的数据,导致数据库最终挂掉(要么系统出bug,要么黑客恶意攻击)</p>
<p>解决方案:</p>
<p>l 在数据库中没有查询到的数据,存储一个特定值到缓存中,这样下次恶意访问就可以去缓存中查询到数据,不会访问到数据库.注意的是这些特定的key,需要设置过期时间，避免黑客攻击时，大量的无效key把redis存满。</p>
<p>缓存雪崩，大规模的key失效，大量的请求通过key访问到数据库，导致数据库直接崩溃,然后系统直接瘫痪.</p>
<p>解决方案:</p>
<p>l 事前:保证redis集群的高可用性,redis cluster,主从机制;</p>
<p>l 事中:hystrix（熔断器）限流+降级,避免数据库被打死.高并发的访问量走hystrix限流组件,让访问量保持在数据库最大负载范围内,保证数据库不被打死,系统可以继续使用.剩余的请求走降级组件,返回一些默认的值或者是友情提示等</p>
<p>l 事后:redis持久化机制,尽快回复缓存集群,一旦重启,自动从磁盘上加载数据,回复内存中的数据</p>
<p>缓存击穿：</p>
<p>缓存与数据库不一致，修改数据时，数据库和缓存数据不一致。</p>
<p>最初级的缓存不一致:</p>
<p>出现场景：</p>
<p>l 先修改数据库,再删除缓存,如果修改缓存失败,就会导致数据库中式新数据,缓存中是旧数据,数据不一致</p>
<p>解决思路:</p>
<p>l 先删除缓存,再修改数据库,如果删除缓存成功,修改数据库失败,那么数据库中是旧数据,缓存中是空的,读的时候缓存中没有,去数据库中读旧数据,然后更新到缓存中去</p>
<p>高并发场景下数据库与缓存的数据不一致:</p>
<p>出现场景：</p>
<p>l 读写并发请求,导致数据库和缓存中的数据不一致,在写请求删除缓存,修改数据库库存还未成功时,查询库存的请求就发来,先去缓存中查询,发现是空,然后去数据库中查,然后将结果放入缓存中,然后修改库存的操作成功,导致数据库中是新数据,缓存中是旧数据</p>
<p>解决思路:</p>
<p>l 相同的商品id,进行哈希取值,再加上对内存队列的数量进行取模,每个商品都可以路由到某一个内存队列中,然后将去请求和写请求串行化,这样就可保证一定不会出现不一致的情况,但是会导致系统的吞吐量会大幅降低</p>
<p>缓存并发竞争，同一时间，多个线程来执行，操作同一个key。</p>
<p>解决思路:</p>
<p>l 方式一：分布式锁,（zookeeper分布式锁），确保同一时间,只能由一个系统实例在操作某个key,别的实例不被允许读和写</p>
<p>l 方式二：乐观锁 ，每次要写之前,先判断这个value的时间戳是否比缓存里的更新,如果新就允许写.</p>
<p>​</p>
<p><strong>5.</strong> <strong>为什么redis是单线程的但是还可以支撑高并发?</strong></p>
<p>l 纯内存操作【主要】</p>
<p>l 是基于非阻塞的IO多路复用机制,由监听程序轮询等待的事件,然后压入队列,可以达到一个线程同时处理多个io请求的目的【IO多路复用机制】</p>
<p>l 单线程避免了多线程的频繁切换问题</p>
<p><strong>6.</strong> <strong>Redis由哪些数据类型,分别在哪些场景下使用?</strong></p>
<p>l String,存储基本的类型</p>
<p>l List,有序列表,比如之前项目中的广告缓存,用的就是list集合进行缓存的,它可以用于比如存储粉丝列表,文章的评论列表等等</p>
<p>l Set,无序列表,它最主要的特点就是去重,比如微博上查询两个明星的共同粉丝,就可以用set进行去重</p>
<p>l SortSet,它主要是在set的基础上加上了排序功能</p>
<p>l Hash,类似map的集合,一般可以用来存储对象,我们系统中的购物车对象就是以hash类型存储在redis中,key就是用户的id,value就是购物车对象</p>
<p>​</p>
<p><strong>7.</strong> <strong>Redis过期策略</strong></p>
<p>l 定期删除配合惰性删除【主动删除+被动删除】</p>
<p>l 定期删除：1s中执行10【可配置】次删除任务，总占用时长250ms【可配置】，每次删除任务时长25ms： 循环执行随机抽样，删除过期的数据；单次循环何时结束：时间到了或者抽样的过期比例小于指定值【25%】。</p>
<p>总结：循环操作，抽样删除。绝不是全部key的扫描，代价太大。</p>
<p>l 惰性删除,就是当你获取key时,redis就会检查一下,如果key过期了,就删除,不会返回,如果没过期就返回</p>
<p>过期的时间如何存储：hash 【设置了过期时间的key：过期时间】</p>
<p><strong>8.</strong> <strong>内存淘汰策略：</strong></p>
<p>Redis内存满了怎么办，Redis使用内存淘汰机制来解决了这个问题。</p>
<p>Ø noevication:当内存不足以容纳写入新数据时,新写入操作就会报错</p>
<p>Ø allkeys-lru:当内存不足以容纳新写入数据时,在键空间中,移除最近最少使用的key</p>
<p>Ø allkeys-lfu：从所有键中驱逐使用频率最少的键</p>
<p>Ø allkeys-random:在键空间中,随机移除某个key</p>
<p>Ø volatile-lru:在设置了过期时间的键空间中,移除最近最少使用的</p>
<p>Ø volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</p>
<p>Ø volatile-random:在设置了过期时间的键空间中,随机移除某个key</p>
<p>Ø volatile-ttl:在设置了过期时间的键空间中,快过期的key优先移除</p>
<p>​</p>
<p><strong>9.</strong> <strong>怎样做redis支撑高并发(读多写少用缓存,读少写多用队列)</strong></p>
<p>主从+哨兵   或者  分片集群</p>
<p>主从数据同步：全量同步 + 增量同步</p>
<p>哨兵作用：监控【主管下线+客观下线】qorum</p>
<p>​          故障转移：</p>
<p>​				1、选择话事人【哨兵，谁先发现】</p>
<p>​           	2、开始故障转移：从slave节点中选择一个新的主【策略：排除响应差的、偏移量和master保持一直的】；新的主执行slaveof no one ；其他从执行slaveof 新主 ；挂点的主配置文件强制写入 slaveof 新主。</p>
<p>​			通知：java客户端，连接的是哨兵的地址。</p>
<p>分片集群：</p>
<p>数据如何分布：散列槽【16384个】</p>
<p><strong>10.</strong> <strong>redis的持久化</strong></p>
<p>如果没有持久化,遇到灾难性故障时,就会丢失所有数据，如果开启持久化到磁盘,定期备份到云服务上,就能保证遇到灾难性故障,就不会丢失全部数据</p>
<p>l RDB</p>
<p>当redis需要做持久化时,redis会fork一个子进程,将数据写到磁盘写上一个临时RDB文件中,当子进程完成写临时文件后,将原来的RDB换掉</p>
<p>优势:</p>
<p>适合做冷备份,在最坏的情况下,恢复数据要比AOF快</p>
<p>对redis对外提供读写服务,影响服务非常小</p>
<p>RDB数据快照文件更少</p>
<p>l AOF</p>
<p>可以做到更精细的持久化,redis每执行一个修改数据的命令,都会将它添加到os cache中,一般会每个一秒执行一次fsync操作,保证将os cache中的数据写入磁盘中AOF日志文件中,AOF日志文件以append-only模式写入,文件不容易破损,在AOF日志过大时,就会出现后台重写</p>
<p>优势:</p>
<p>AOF可以更好的保护数据不丢失,丢失的数据更少</p>
<p>AOF日志文件以append-only模式写入,没有磁盘寻址的开销,写入性能非常高</p>
<p>AOF日志过大时,也不会影响客户端的读写</p>
<p>​</p>
<p>l RDB和AOF到底如何抉择</p>
<p>综合使用两种持久化机制,用AOF保证数据不丢失,作为数据恢复的第一选择,用RDB来做不同程度的冷备份,在AOF文件丢失或者损坏不可用的情况下,用RDB来进行快速的数据回复</p>
<p><strong>11.</strong> <strong>redis怎么设置缓存大小【3<strong><strong>2</strong></strong>g】</strong></p>
<p>打开redis配置文件</p>
<p>示例：maxmemory 100mb</p>
<p>单位：mb,gb。</p>
<p>默认为0，没有指定最大缓存，如果有新的数据添加，吃满服务器的物理内存，直到超过最大内存，则会使redis崩溃，所以一点要设置。</p>
<p>设置maxmemory之后，配合的要设置缓存数据回收策略, 可以通过设置LRU算法来删除部分key，释放空间(LRU是Least Recently Used 近期最少使用算法。)。</p>
<p>就可以修改缓存大小为16gb.</p>
<p>建议是物理内存的50%以下。</p>
<p><strong>12.</strong> <strong>redis集群主从数据如何同步</strong></p>
<p>全量复制	+	增量复制</p>
<p><strong>13.</strong> <strong>Redis管道【<strong><strong>pipeline</strong></strong>】</strong></p>
<p>批量执行redis命令，结果批量返回。</p>
<p><strong>14.</strong> <strong>R<strong><strong>edis支持</strong></strong>事务，但是事务不能回滚，只能放弃执行</strong></p>
<p>Multi：开启事务</p>
<p>Exec：执行事务</p>
<p>Discard：放弃执行事务</p>
<p><strong>15.</strong> <strong>R****edis实现分布式锁</strong></p>
<h1>七、 Elasticsearch</h1>
<p><strong>1.Elasticsearch是如何实现Master选举的</strong></p>
<p>v Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；</p>
<p>v 对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。</p>
<p>v 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p>
<p><strong>2.在并发情况下，Elasticsearch如果保证读写一致？</strong></p>
<p>v 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
<p>v 另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>
<p>v 对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。</p>
<p>**3.**<strong>Elasticsearch索引文档的过程</strong></p>
<p>协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片。<br>
　　shard = hash(document_id) % (num_of_primary_shards)<br>
　　当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时（默认是每隔1秒）写入到Filesystem Cache，这个从Momery Buffer到Filesystem 　　Cache的过程就叫做refresh；<br>
　　当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush；<br>
　　在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。<br>
　　flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时；</p>
<p>**4.**<strong>Elasticsearch更新和删除文档的过程</strong></p>
<p>删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；<br>
　　磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。<br>
　　在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p>
<p>**5.**<strong>Elasticsearch搜索的过程</strong></p>
<p>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；<br>
　　在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。<br>
　　每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。<br>
　　接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。<br>
　　补充：Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term和Document frequency，这个评分更准确，但是性能会变差。</p>
<p>**6.**<strong>ElasticSearch中的集群、节点、索引、文档、类型是什么？</strong></p>
<p>群集是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名称标识，默认情况下为“elasticsearch”。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分。</p>
<p>节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。</p>
<p>索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。 MySQL =&gt;数据库ElasticSearch =&gt;索引</p>
<p>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构（字段），但是对于通用字段应该具有相同的数据类型。 MySQL =&gt; Databases =&gt;Tables =&gt; Columns / Rows ElasticSearch =&gt; Indices =&gt; Types =&gt;具有属性的文档</p>
<p>类型是索引的逻辑类别/分区，其语义完全取决于用户。</p>
<p>**7.**<strong>elasticsearch 索引数据多了怎么办，如何调优</strong></p>
<p>使用bulk API<br>
初次索引的时候，把 replica 设置为 0<br>
增大 threadpool.index.queue_size<br>
增大 indices.memory.index_buffer_size<br>
增大 index.translog.flush_threshold_ops<br>
增大 index.translog.sync_interval<br>
增大 index.engine.robin.refresh_interval</p>
<h1>八、 Dubbo和Zookeeper</h1>
<p><strong>1.</strong> <strong>dubbo的工作流程</strong></p>
<p>l provider向注册中心去注册自己为一个服务</p>
<p>l consumer去注册中心订阅服务,注册中心会通知consumer注册好的服务,consumer会将provider的地址等信息拉取到本地缓存</p>
<p>l consumer去调用provider</p>
<p>l consumer和provider都异步的通知监控中心</p>
<p>![img](file:///C:\Users\Jarvis\AppData\Local\Temp\ksohtml13616\wps21.jpg)</p>
<p><strong>2.</strong> <strong>Dubbo的通信原理？</strong></p>
<p>l Dubbo底层使用 hessain2进行二进制序列化进行远程调用</p>
<p>l Dubbo底层使用 netty框架进行异步通信。NIO</p>
<p><strong>3.</strong> <strong>dubbo负载均衡策略有哪些?</strong></p>
<p>l random loadbalance</p>
<p>默认情况下,dubbo是random loadbalance随机调用实现负载均衡,可以对provider不同实例设置不同的权重,会按照权重来负载均衡,权重大分配的流量高</p>
<p>l roundrobin loadbalance</p>
<p>默认就是均匀地将流量达到各个机器上,值得注意的是,要根据机器的性能,调整权重。</p>
<p>l leastactive loadbalance</p>
<p>dubbo自动感知,如果某个机器性能越差,那么接收的请求就越少,给不活跃的机器更少的请求</p>
<p>l consistanthash loadbalance</p>
<p>一致性hash算法,相同参数的请求一定分发到同一个provider上,provider挂掉的时候,会基于虚拟机节点均匀分配甚于的流量,抖动不会太大.适用于订单,同一个订单的操作,分配到同一个机器上,这样就可以避免高并发场景下,数据库和缓存中数据不一致的情况</p>
<p><strong>3.zookeeper注册中心挂了，dubbo可以继续使用吗？</strong></p>
<p>可以,因为刚开始dubbo初始化的时候,消费者会将提供者的地址等信息缓存到dubbo,注册中心挂了dubbo可以继续通信</p>
<p><strong>4.zookeeper 都有哪些功能？</strong></p>
<p>l 集群管理：监控节点存活状态、运行请求等。</p>
<p>l 主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</p>
<p>l 分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</p>
<p>l 命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p>
<p><strong>5.Zookeeper的watch机制（通知机制）</strong></p>
<p>Zookeeper系统中其实类似于window系统中的文件夹，zookeeper可以建立普通节点和临时节点，但是每个节点只能有一个，例如：/a/b/c节点已经存在，那么再来申请/a/b/c的节点就会失败。此时可以设置watch此节点，当/a/b/c节点删除后，会通知watch此节点的所有线程，线程再来创建节点，完成设定的任务。（分布式锁，高可用性）</p>
<p><strong>6.zookeeper 怎么保证主从节点的状态同步？</strong></p>
<p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<p>**7.**<strong>什么是 zab 协议</strong></p>
<p>ZAB 是 Zookeeper 原子广播协议的简称</p>
<p>整个ZAB协议主要包括消息广播和崩溃恢复两个过程，进一步可以分为三个阶段，分别是：</p>
<p>发现 Discovery<br>
同步 Synchronization<br>
广播 Broadcast</p>
<p>组成ZAB协议的每一个分布式进程，都会循环执行这三个阶段，将这样一个循环称为一个主进程周期。</p>
<p><strong>8.如果zookeeper服务挂了怎么办？</strong></p>
<p>注册中心对等集群，任意一台宕掉后，会自动切换到另一台</p>
<p>​    注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯</p>
<p>服务提供者无状态，任一台宕机后，不影响使用</p>
<p>服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复</p>
<h1>九、 分布式系统</h1>
<p><strong>1.</strong> <strong>怎么实现远程通信</strong></p>
<p>什么是远程通信:简单来说，就是一个系统去调用另一个系统中的数据.</p>
<p>常见的有三种方式：</p>
<p>(1)Webservice的方式：</p>
<p>​    1)优点：跨语言跨平台</p>
<p>​    2)缺点：它是基于soap协议的，使用http+xml的方式进行数据传输，http是应用层协议，传输效率不是很高，而且xml的解析也比 较费时，所以项目内部进行通信的时候，不建议使用Websservice的方式</p>
<p>(2)restful形式的服务：</p>
<p>1)优点：restful本身就是http，使用的是http+json的方式进行数据传输，因为json数据本身是非常简洁的，所以它比webservice的 传输效率更高；手机app端一般都使用该方法，其他很多项目也是用这种方式</p>
<p>​    2)缺点：如果服务太多的话，会出现服务之间调用关系混乱，此时就需要治理服务</p>
<p>(3)Dubbo：</p>
<p>​     使用的是RPC协议进行远程调用，RPC协议是一个二进制协议，直接使用的socket进行通信，传输效率高，并且可以统计出系统 之间的调用关系和调用次数系统分布式SAO系统的内部通信推荐使用dubbo</p>
<p><strong>2.</strong> <strong>分布式事务</strong></p>
<p>TCC方案(Try,Confirm,Cancel)</p>
<p>l Try:此阶段是对各个服务的资源做检测以及对资源进行锁定或者预留</p>
<p>l Confirm:此阶段是在各个服务中执行实际的操作</p>
<p>l Cancel:如果任何一个服务的业务执行出错,就要进行补偿,将已经执行成功的业务逻辑回滚操作</p>
<p>l 这种方案的事务回滚实际上是依赖于自己写代码来回滚和补偿,补偿代码巨大,除了一些严格保证分布式事务的场景,比如和资金,订单相关的业务,尽量少使用</p>
<p>​</p>
<p>本地消息表(ebay)</p>
<p>l A系统在自己本地一个事务里操作同时,插入一条数据到消息表</p>
<p>l A系统将这个消息发送到MQ中</p>
<p>l B系统接收到消息之后,在一个事务里,往自己本地消息表中插入一条数据,同时执行其他业务操作,如果这个消息已经被处理了,那么此时这个消息会回滚,这样保证不会重复处理消息</p>
<p>l B系统执行成功后,就会更新本地消息表的状态以及A系统消息表的状态</p>
<p>l 如果B系统处理失败了,就不会更新消息表状态,A系统会定时扫描自己的消息表,没有处理的消息,会再次发送到MQ中,让B处理</p>
<p>l 这个方案为了保证最终一致性,哪怕B事务失败了,A会不断重发消息,直到B成功为止;此外最大的问题是严重依赖数据库的消息表来管理事务,不适用高并发的场景,扩展性能差</p>
<p>可靠消息最终一致性方案</p>
<p>l 这个方案是基于阿里的rocketMQ(3.3.6之前)来实现,是目前比较国内比较常用的方案</p>
<p>l A系统发送一个prepared消息到mq,如果prepared消息发送失败,就直接取消操作</p>
<p>l 如果消息发送成功,就接着执行本地事务,如果成功就给mq发送确认消息,如果失败就告诉mq回滚消息</p>
<p>l 如果发送了确认消息,B系统就会接收到,然后执行本地的事务</p>
<p>l mq会定时轮询所有prepared消息,回调接口,所有没发送确认消息的,问你继续重试还是回滚,然后A系统就去查看本地事务的状态,如果回滚,告诉mq回滚消息,如果成功了就重新发送确认消息</p>
<p>l 如果B系统的事务失败,自动不断重试,直到成功,如果实在不行就让B系统本地回滚,然后想办法通知A系统也回滚,或者是发送警报由人工手动回滚和补偿</p>
<p>​</p>
<p>最大努力通知方案</p>
<p>l A系统本地事务执行完后,发送消息到MQ</p>
<p>l 有个服务会消费MQ中的消息,然后写入数据库记录下来,或者放入内存队列中,接着调用B系统的接口</p>
<p>l 要是B系统执行成功就ok,执行失败,就最大努力通知服务定时尝试重新调用B系统,反复N次,实在不行就放弃</p>
<p><strong>3.</strong> <strong>系统的高并发问题是怎么解决的</strong></p>
<p>并发问题高，这个问题的解决方案是一个系统性的，系统的每一层面都需要做优化：</p>
<p>1） 数据层</p>
<p>a)    集群</p>
<p>b)    分表分库</p>
<p>c)    开启索引</p>
<p>d)    开启缓存</p>
<p>e)    表设计优化</p>
<p>f)     Sql语句优化</p>
<p>g)    缓存服务器（提高查询效率，减轻数据库压力）</p>
<p>h)    搜索服务器（提高查询效率，减轻数据库压力）</p>
<p>2）项目层</p>
<p>a)    采用面向服务分布式架构（分担服务器压力，提高并发能力）</p>
<p>b)    采用并发访问较高的详情系统采用静态页面</p>
<p>c)    使用页面缓存</p>
<p>d)    用 ActiveMQ使得业务进一步进行解耦，提高业务处理能力</p>
<p>e)    使用分布式文件系统存储海量文件</p>
<p>3） 应用层</p>
<p>a)    Nginx服务器来做负载均衡</p>
<p>b)    Lvs做二层负载</p>
<p><strong>4.</strong> <strong>分布式锁的问题</strong></p>
<p>针对分布式锁的实现，目前比较常用的有以下几种方案：</p>
<p>1.基于数据库实现分布式锁</p>
<p>2.基于缓存（redis，memcached，tair）实现分布式锁</p>
<p>3.基于 zookeeper实现分布式锁</p>
<h1>十、 微服务架构</h1>
<h2 id="1-SpringCloud常用组件有哪些？"><strong>1.</strong> <strong>SpringCloud常用组件有哪些？</strong></h2>
<p>Ø 注册中心：Eureka、Nacos、Consoul</p>
<p>Ø 配置中心：Nacos、SpringCloud Config</p>
<p>Ø 网关：Zuul、SpringCloud Gateway</p>
<p>Ø 服务调用：Feign、Dubbo</p>
<p>Ø 负载均衡：Ribbon</p>
<p>Ø 微服务保护：服务熔断/降级：Hystrix</p>
<h2 id="2-注册中心"><strong>2.</strong> <strong>注册中心</strong></h2>
<h4 id="1-eureka和nacos的区别"><strong>1.</strong> <strong>eureka和nacos的区别</strong></h4>
<p>Ø Nacos与eureka的共同点</p>
<p>- 都支持服务注册和服务拉取</p>
<p>- 都支持服务提供者心跳方式做健康检测</p>
<p>Ø Nacos与Eureka的区别</p>
<p>- Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</p>
<p>- 临时实例心跳不正常会被剔除，非临时实例则不会被剔除</p>
<p>- Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</p>
<p>- Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</p>
<h4 id="2-Eureka的工作原理"><strong>2.</strong> <strong>Eureka的工作原理</strong></h4>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/caffafae2e36">Eureka注册中心原理 - 简书 (jianshu.com)</a></p>
<h4 id="3-Z-ookeeper"><strong>3.</strong> <strong>Z****ookeeper</strong></h4>
<p>详见zookeeper课程</p>
<h2 id="3-配置中心"><strong>3.</strong> <strong>配置中心</strong></h2>
<h2 id="4-网关SpringCloud-Gateway"><strong>4.</strong> <strong>网关SpringCloud Gateway</strong></h2>
<h4 id="1-网关路由包含哪些部分？"><strong>1.</strong> <strong>网关路由包含哪些部分？</strong></h4>
<p>网关路由包含：id、url、断言和过滤器</p>
<h4 id="2-你们项目中网关有哪些作用？"><strong>2.</strong> <strong>你们项目中网关有哪些作用？</strong></h4>
<p>我们项目中网关是作为客户端访问的入口，同时也在网关端进行了权限检验和限流的操作。</p>
<h4 id="3-网关过滤器有哪些类型？"><strong>3.</strong> <strong>网关过滤器有哪些类型？</strong></h4>
<p>局部过滤器 GatewayFilter：作用在某一个路由上</p>
<p>全局过滤器 GlobalFilter：作用全部路由上</p>
<h4 id="4-说说你在开发中用到了哪些断言工厂？"><strong>4.</strong> <strong>说说你在开发中用到了哪些断言工厂？</strong></h4>
<p>Predicate来自于java8的接口。Predicate接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。</p>
<p>Spring Cloud Gateway内置了许多Predict，比如Cookie 路由断、Header 路由断言、Path路由断言。</p>
<p>其中我们在项目中使用的比较多的断言有Path路由断言</p>
<h4 id="5-网关中如何实现跨域？"><strong>5.</strong> <strong>网关中如何实现跨域？</strong></h4>
<p>在网关的yml配置文件中，通过如下配置实现</p>
<p>spring:</p>
<p>cloud:</p>
<p>​    gateway:</p>
<p>​      globalcors:</p>
<p>​        cors-configurations:</p>
<p>​          ‘[/**]’:</p>
<p>​            max-age: 3600</p>
<p>​            allowed-origin-patterns: “*”</p>
<p>​            allowed-headers: “*”</p>
<p>​            allow-credentials: true</p>
<p>​            allowed-methods:</p>
<p>​              - GET</p>
<p>​              - POST</p>
<p>​              - DELETE</p>
<p>​              - PUT</p>
<p>​              - OPTION</p>
<h4 id="6-网关的负载均衡是基于什么实现的？"><strong>6.</strong> <strong>网关的负载均衡是基于什么实现的？</strong></h4>
<p>Ribbon</p>
<h4 id="7-说说Zuul和Gateway的区别？"><strong>7.</strong> <strong>说说</strong>Zuul和Gateway的区别？</h4>
<p>1、gateway对比zuul多依赖了spring-webflux，内部实现了限流、负载均衡等，扩展性也更强，但同时也限制了仅适合于Spring Cloud套件。</p>
<p>zuul则可以扩展至其他微服务框架中，其内部没有实现限流、负载均衡等。</p>
<p>2、zuul仅支持同步，</p>
<p>gateway支持异步。</p>
<p>3、gateway线程开销少，支持各种长连接、websocket，spring官方支持，但运维复杂，</p>
<p>zuul编程模型简单,开发调试运维简单，有线程数限制，延迟堵塞会耗尽线程连接资源。</p>
<h2 id="5-远程调用Feign"><strong>5.</strong> <strong>远程调用Feign</strong></h2>
<p>Feign和OpengFeign的区别</p>
<p>Ø 他们底层都是内置了Ribbon，去调用注册中心的服务。eign是Netflix公司写的，是SpringCloud组件中的一个轻量级RESTful的HTTP服务客户端，是SpringCloud中的第一代负载均衡客户端。</p>
<p>Ø OpenFeign是SpringCloud自己研发的，在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。是SpringCloud中的第二代负载均衡客户端。Feign本身不支持Spring MVC的注解，使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务</p>
<p>Ø OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://dengzm2022.github.io">Dengzm2022</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://dengzm2022.github.io/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98/">http://dengzm2022.github.io/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://dengzm2022.github.io" target="_blank">张佩服的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/07/02/8dSbYDP6t1NiexJ.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/"><img class="prev-cover" src="https://s2.loli.net/2022/07/02/w9sp28r3gMRuvLk.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题二</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/31/JavaEE_Collection/"><img class="next-cover" src="https://s2.loli.net/2022/07/02/EH71wmGpMUlzkqX.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaEE_Collection</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/" title="面试题二"><img class="cover" src="https://s2.loli.net/2022/07/02/w9sp28r3gMRuvLk.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-18</div><div class="title">面试题二</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjczOS8zMzIwMw=="></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/07/02/wevdzYikc6EoaXn.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Dengzm2022</div><div class="author-info__description">再见少年拉满弓&#44;不惧岁月不惧风</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Dengzm2022"><i class="fab fa-github"></i><span>我的 Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Blog Blog , I am here</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">一、 JAVA基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、基础内容【必须】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">1. JDK 和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">2. 抽象类与接口区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">3. &#x3D;&#x3D; 和 equals 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Stream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">4. Stream常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-final-%E5%9C%A8-Java-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">5. final 在 Java 中有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">6. String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%ADreplace%E5%92%8CreplaceAll%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.0.7.</span> <span class="toc-text">7. 字符串中replace和replaceAll的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-String-StringBuilder-StringBuffer%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.0.8.</span> <span class="toc-text">8. String,    StringBuilder,StringBuffer三者的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.0.9.</span> <span class="toc-text">9. JAVA反射机制提供了什么功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.0.10.</span> <span class="toc-text">10. 常见的异常类有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.0.11.</span> <span class="toc-text">11. Java中异常处理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Java%E4%B8%ADfinally%E5%92%8Creturn%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.1.0.12.</span> <span class="toc-text">12. Java中finally和return执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.0.13.</span> <span class="toc-text">13. 常见的基本排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E3%80%81JVM%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.</span> <span class="toc-text">1.2**、JVM虚拟机&amp;类加载**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E3%80%90%E5%BF%85%E9%A1%BB%EF%BC%8C%E8%AE%B0%E4%BD%8F%E7%BB%93%E6%9E%9C%E3%80%91"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1. Java 内存区域【必须，记住结果】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JAVA%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%90%E8%AE%B0%E4%BD%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E3%80%91"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">2. JAVA中垃圾回收机制【记住常见的垃圾回收算法】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">3. 类加载过程【必须】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">4. 类的实例化方法调用顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">5. 对象创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Java-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">6. Java****内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.2.0.7.</span> <span class="toc-text">7. java内存泄漏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.3.</span> <span class="toc-text">1.4**、多线程【必须】**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">1. 线程和进程的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">2. 创建线程的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java%E4%B8%ADwait%E6%96%B9%E6%B3%95%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">3. Java中wait方法和sleep方法的不同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">4. 线程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB-%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">5. 线程池的种类**【必须】**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9F%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">6. 线程池的核心参数？【必须】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.3.0.7.</span> <span class="toc-text">7. 线程池都有哪些状态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.0.8.</span> <span class="toc-text">8. 线程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.0.9.</span> <span class="toc-text">9. volatile与synchronized的区别，底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.3.0.10.</span> <span class="toc-text">10. 什么是死锁？【必须】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81%EF%BC%9F%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.3.0.11.</span> <span class="toc-text">11. 怎么防止死锁？【必须】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E3%80%81IO%E6%A8%A1%E5%9E%8B%E3%80%903%E5%B9%B4%E5%B7%A6%E5%8F%B3%E3%80%91"><span class="toc-number">1.4.</span> <span class="toc-text">1.5**、IO模型【3年左右】**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">IO对比总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E3%80%81Java%E5%AE%B9%E5%99%A8%E3%80%90%E5%BF%85%E9%A1%BB%E3%80%91"><span class="toc-number">1.5.</span> <span class="toc-text">1.6**、Java容器【必须】**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java-%E5%AE%B9%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">1. Java 容器都有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">2. 数组与链表的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Map%E9%9B%86%E5%90%88%E5%87%A0%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">3. Map集合几种遍历方式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-List%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">4. List集合的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">5. 如何实现数组和 List 之间的转换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.0.6.</span> <span class="toc-text">6. ArrayList 和 LinkedList 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-list%E3%80%81set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.0.7.</span> <span class="toc-text">7. list、set和map的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-HashMap%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.0.8.</span> <span class="toc-text">8. HashMap的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-A-rrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">1.5.0.9.</span> <span class="toc-text">9. A****rrayList的扩容规则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E8%AF%B4%E4%B8%80%E4%B8%8B-HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E3%80%90%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%E3%80%91"><span class="toc-number">1.5.0.10.</span> <span class="toc-text">10. 说一下 HashMap 的实现原理？【重中之重】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%AF%B4%E4%B8%80%E4%B8%8B-HashSet-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.5.0.11.</span> <span class="toc-text">11. 说一下 HashSet 的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-CurrentHashMap%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">1.5.0.12.</span> <span class="toc-text">12. CurrentHashMap了解吗?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E3%80%81Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">1.7**、Java设计模式**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">1. 常见设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%87%92%E6%B1%89%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">2. 单例设计模式中懒汉式和饿汉式的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">二、 WEB</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">三、 数据库【必须】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">四、 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81Spring"><span class="toc-number">4.1.</span> <span class="toc-text">4**.1、Spring**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#S-pring-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">S****pring 有哪些主要模块？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC%E5%92%8CDI%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">IOC和DI【重点】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">Spring AOP【重点】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.0.4.</span> <span class="toc-text">Spring中Bean的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.0.5.</span> <span class="toc-text">Spring框架实现实例化和依赖注入的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.1.0.6.</span> <span class="toc-text">Spring常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory%E7%B1%BB%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.0.7.</span> <span class="toc-text">BeanFactory类图结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.0.8.</span> <span class="toc-text">SpringBean的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%EF%BC%9F%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91"><span class="toc-number">4.1.0.9.</span> <span class="toc-text">Spring 怎么解决循环依赖问题？【重要】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.1.0.10.</span> <span class="toc-text">Spring 框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.1.0.11.</span> <span class="toc-text">Spring事务传播行为</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81Spring-MVC"><span class="toc-number">4.2.</span> <span class="toc-text">4**.2、Spring****MVC**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">SpringMVC****执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">SpringMVC常用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springmvc%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">springmvc获取参数的几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%EF%BC%9F"><span class="toc-number">4.2.0.4.</span> <span class="toc-text">Spring MVC的异常处理 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#S-pringmvc%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%9F"><span class="toc-number">4.2.0.5.</span> <span class="toc-text">S****pringmvc文件上传？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F"><span class="toc-number">4.2.0.6.</span> <span class="toc-text">SpringMVC拦截器？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81Springboot"><span class="toc-number">4.3.</span> <span class="toc-text">4**.3、Springboot**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-boot-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%EF%BC%9F"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">spring boot 有哪些方式可以实现热部署？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">SpringBoot 的常用注解有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">SpringBoot 有哪几种读取配置的方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot-%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">4.3.0.4.</span> <span class="toc-text">SpringBoot 配置加载顺序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Boot-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%A4%9A%E5%A5%97%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">4.3.0.5.</span> <span class="toc-text">Spring Boot 如何定义多套不同环境配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81Mybatis-Mybatis-plus"><span class="toc-number">4.4.</span> <span class="toc-text">4**.4、Mybatis&amp;Mybatis-plus**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%92%8C-%E4%B9%A6%E5%86%99%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.0.1.</span> <span class="toc-text">Mybatis中使用#和$书写占位符有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81SQL"><span class="toc-number">4.4.0.2.</span> <span class="toc-text">动态SQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mapper%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%84%E8%8C%83"><span class="toc-number">4.4.0.3.</span> <span class="toc-text">Mapper动态代理规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.4.0.4.</span> <span class="toc-text">Mybatis常用注解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">五、 MQ消息队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">六、 Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">七、 Elasticsearch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">八、 Dubbo和Zookeeper</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">九、 分布式系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">十、 微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpringCloud%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">1. SpringCloud常用组件有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">10.2.</span> <span class="toc-text">2. 注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-eureka%E5%92%8Cnacos%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.0.1.</span> <span class="toc-text">1. eureka和nacos的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Eureka%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.2.0.2.</span> <span class="toc-text">2. Eureka的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Z-ookeeper"><span class="toc-number">10.2.0.3.</span> <span class="toc-text">3. Z****ookeeper</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">10.3.</span> <span class="toc-text">3. 配置中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BD%91%E5%85%B3SpringCloud-Gateway"><span class="toc-number">10.4.</span> <span class="toc-text">4. 网关SpringCloud Gateway</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-number">10.4.0.1.</span> <span class="toc-text">1. 网关路由包含哪些部分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%BD%91%E5%85%B3%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">10.4.0.2.</span> <span class="toc-text">2. 你们项目中网关有哪些作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">10.4.0.3.</span> <span class="toc-text">3. 网关过滤器有哪些类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82%EF%BC%9F"><span class="toc-number">10.4.0.4.</span> <span class="toc-text">4. 说说你在开发中用到了哪些断言工厂？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BD%91%E5%85%B3%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">10.4.0.5.</span> <span class="toc-text">5. 网关中如何实现跨域？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%BD%91%E5%85%B3%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">10.4.0.6.</span> <span class="toc-text">6. 网关的负载均衡是基于什么实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AF%B4%E8%AF%B4Zuul%E5%92%8CGateway%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.4.0.7.</span> <span class="toc-text">7. 说说Zuul和Gateway的区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8Feign"><span class="toc-number">10.5.</span> <span class="toc-text">5. 远程调用Feign</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/" title="面试题二"><img src="https://s2.loli.net/2022/07/02/w9sp28r3gMRuvLk.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题二"/></a><div class="content"><a class="title" href="/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/" title="面试题二">面试题二</a><time datetime="2022-09-18T12:07:20.000Z" title="发表于 2022-09-18 20:07:20">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img src="https://s2.loli.net/2022/07/02/8dSbYDP6t1NiexJ.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/2022/09/18/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2022-09-18T12:03:49.000Z" title="发表于 2022-09-18 20:03:49">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/JavaEE_Collection/" title="JavaEE_Collection"><img src="https://s2.loli.net/2022/07/02/EH71wmGpMUlzkqX.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaEE_Collection"/></a><div class="content"><a class="title" href="/2022/07/31/JavaEE_Collection/" title="JavaEE_Collection">JavaEE_Collection</a><time datetime="2022-07-31T10:26:03.000Z" title="发表于 2022-07-31 18:26:03">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/java-EE/" title="JavaEE_"><img src="https://s2.loli.net/2022/07/02/VQg1q3jRatv9hDB.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaEE_"/></a><div class="content"><a class="title" href="/2022/07/31/java-EE/" title="JavaEE_">JavaEE_</a><time datetime="2022-07-31T10:26:03.000Z" title="发表于 2022-07-31 18:26:03">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/27/EastWind/" title="EastWind"><img src="https://s2.loli.net/2022/07/02/EH71wmGpMUlzkqX.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EastWind"/></a><div class="content"><a class="title" href="/2022/07/27/EastWind/" title="EastWind">EastWind</a><time datetime="2022-07-27T12:27:13.000Z" title="发表于 2022-07-27 20:27:13">2022-07-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/07/02/8dSbYDP6t1NiexJ.webp')"><div id="footer-wrap"><div class="copyright">&copy;2022 By Dengzm2022</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">再见少年拉满弓&#44;不惧岁月不惧风</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'oVIFJKTtshmeJxzLo8DPUYyP-MdYXbMMI',
      appKey: 'WA2yOsusWy9K3bzJsqlYgKYa',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Livere' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="3136952023" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Blog,Blog,我在" data-fontsize="15px" data-random="false" async="async"></script><script src="//code.tidio.co/3brvxoobajzui7vajovvqggd5gspcr7w.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?Dengzm2022";
            var git_color =['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'];
            var git_user ="Dengzm2022";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>